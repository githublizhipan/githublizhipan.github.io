{"meta":{"title":"现在做的一切都是在为未来打基础","subtitle":"","description":"","author":"Mr Lee.","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About me","date":"2020-07-31T00:27:29.000Z","updated":"2020-08-05T08:18:15.117Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一名无名小卒 qq: 32849549879shouji: 123153465"},{"title":"分类","date":"2020-08-09T11:56:01.000Z","updated":"2020-08-11T13:11:24.638Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"留下你的想法~","date":"2020-08-11T13:12:28.000Z","updated":"2020-08-11T13:13:01.946Z","comments":true,"path":"messageboard/index.html","permalink":"http://yoursite.com/messageboard/index.html","excerpt":"","text":""},{"title":"那些年，我们听过的音乐","date":"2020-08-11T13:13:12.000Z","updated":"2020-08-11T13:13:37.887Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-30T15:05:17.000Z","updated":"2020-08-05T08:18:02.051Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"那些年，我们拍过的回忆","date":"2020-08-11T13:13:49.000Z","updated":"2020-08-11T13:14:14.929Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-06T12:43:11.401Z","updated":"2020-08-06T12:43:11.274Z","comments":true,"path":"tags/photos/index.css","permalink":"http://yoursite.com/tags/photos/index.css","excerpt":"","text":".test { width: 500px; height: 200px; background-color: red; } .iframe { } .audio { margin:auto; width: 350px; height: 90px; } .player-mid .mask { background: #fff; } .img-box1 { margin: auto; width: 80%; } .img1 { width: 100%; height: 350px; }"},{"title":"相册","date":"2020-08-09T11:53:16.560Z","updated":"2020-08-09T11:53:16.560Z","comments":true,"path":"tags/photos/index.html","permalink":"http://yoursite.com/tags/photos/index.html","excerpt":"","text":"那么爱他"}],"posts":[{"title":"C++计蒜客答疑","slug":"c++/8.计蒜客答疑","date":"2020-08-17T02:29:18.200Z","updated":"2020-08-17T09:24:19.658Z","comments":true,"path":"2020/08/17/c++/8.计蒜客答疑/","link":"","permalink":"http://yoursite.com/2020/08/17/c++/8.%E8%AE%A1%E8%92%9C%E5%AE%A2%E7%AD%94%E7%96%91/","excerpt":"","text":"c++类型转换的四种方法 dynamic_cast 将父类指针转换为子类指针。 使用这个功能的前提是，父类（或者他的父类——如果有的话）必须至少要包含一个virtual函数。 转换失败返回nullptr static_cast 当然你也可以使用static_cast。它跟dynamic_cast的区别就是，他不回去检查pAnimal到底是不是Cat，就直接转换给你。如果不是的话，你就会拿到一个野指针，使用它就会发生 undefined behavior。 另外要提到的是，dynamic_cast也可以在父类的几个子类下转换，如果不返回nullptr就代表你的转换成功了，这个指针指向的的确是你需要的类型的对象。而static_cast这样做会有语法错误。 const_cast reinterpret_cast lambda表达式可调用对象： 函数 函数对象 lambda表达式 auto a = [](int a, int b) &#123; return a + b; &#125;; 解释： 每一个 lambda 表达式类型都不同，因此auto不能少，编译器会推导类型 也可以用返回值后置来指定返回值类型 []装的是外部变量, 捕获行为 [n] : 值捕获 [&amp;n] : 引用捕获 [=] : 以值捕获形式捕获外部所有变量 [&amp;] : 以引用捕获形式捕获外部所有变量 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main() &#123; //可调用对象：函数、函数对象、lambda表达式 //返回值类型自动推导 auto a = [](int a, int b) &#123; return a + b; &#125;; //lambda是个对象就是个值，赋值语句不要忘加分号 auto b = [](int a, int b) &#123; return a + b; &#125;; //每一个 lambda 表达式类型都不同 cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; a(231, 64) &lt;&lt; endl; //返回值后置，指定返回值类型 auto c = [](int a, int b) -&gt; double &#123; double c = 12.5; if (rand() % 2) &#123; return c; &#125; else &#123; return a + b; &#125; &#125;; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;int mul(int a, int b) &#123; return a * b;&#125;int add(int a, int b) &#123; return a + b;&#125;int main() &#123; //可调用对象：函数、函数对象、lambda表达式 int n = 10000; auto a = [=](int a, int b) &#123; return a + b + n; &#125;; //lambda是个对象就是个值，赋值语句不要忘加分号 n = 1000000; auto b = [n](int a, int b) &#123; return a + b + n; &#125;; //每一个 lambda 表达式类型都不同 cout &lt;&lt; typeid(a).name() &lt;&lt; endl; cout &lt;&lt; typeid(b).name() &lt;&lt; endl; cout &lt;&lt; a(1, 2) &lt;&lt; endl; cout &lt;&lt; b(1, 2) &lt;&lt; endl; //返回值后置，指定返回值类型 auto c = [](int a, int b) -&gt; double &#123; double c = 12.5; if (rand() % 2) &#123; return c; &#125; else &#123; return a + b; &#125; &#125;; //lambda 表达式可以传入可调用对象也可返回可调用对象 auto d = [](function&lt;int(int, int)&gt; a, function&lt;int(int, int)&gt; b) &#123; return [=](int x) &#123; return a(x, x) + b(x, x); &#125;; &#125;; auto e = d(a, b); cout &lt;&lt; e(12) &lt;&lt; endl; auto f = d(add, mul); cout &lt;&lt; f(3) &lt;&lt; endl; return 0;&#125; 使用placement new和move实现 Vector这一次我们要用之前学习过的关于右值引用和std::move的相关知识，自行实现一个Vector。除此之外，我们还会向大家介绍一个新的知识：“定位放置（placement new)”。 对于已经学习过《C++ 程序设计》的同学，应该知道new运算符的使用方法——而placement new则是new运算符的一种变种。跟 C 语言中的malloc函数不同，new的作用是，首先分配一片大小足够的内存，然后在这片内存上调用指定的构造函数，构造一个对象。而placement new则是在指定的一片分配好的内存上，对对象进行构造。 在这一节，我们将会使用placement new，配合std::move来进行对象构造，并且完成一个Vector类——在《C++ 程序设计》最后一章的实验中，大家应该已经试着自己实现过一个Vector类。而这一节我们要实现的Vector类则更加复杂，功能更多，而且效率更高。 placement new的使用方法如下所示： 1new(位置)Object(构造函数的参数) 具体到这次我们要实现的Vector类，在测试中，我们会使用它来填充元素Element——它在调用不同的构造函数的时候，会输出不同的文字信息。大家需要正确使用std::move，调用正确的构造函数，才能得到正确的结果。 Element类的定义，Vector类的框架与几个构造函数，都已经给出——其中Vector类包含一个指针变量成员items和一个整形变量成员count，分别用来保存堆对象的位置，以及当前已经储存的元素个数。大家需要实现Vector的右值引用构造函数与析构函数，以及以下几个成员函数： void Add(const T&amp; item)这个函数类似于std::vector提供的push_back方法，作用是向当前元素数组的末尾添加一个新的元素——如果内存空间不足的话你就需要对内存进行重新分配，不能让Vector类的使用者自己去考虑数组是否会越界的问题。 bool Insert(const T&amp; item,int index)向索引index的位置插入元素——然后将index后面的元素依次向后移动一个位置。同样，你需要自己处理内存空间问题。除此之外，你还要检查索引是否合法——如果合法则返回true，不合法则直接返回false，不执行任何操作。 bool Remove(int index)删除索引index位置的元素，并且将index后面的所有元素向前移动一位。其他细节跟Insert函数保持一致。 int Contains(const T&amp; item)遍历整个数组，看是否包含元素item。如果包含则返回item的索引，如果不包含则返回-1 void Clear()清除Vector的所有元素，将指针置为nullptr，将计数器归零——注意为了避免内存泄漏，**Clear()和Vector的析构函数必须要先调用所有元素的析构函数再对堆内存进行free** 所有成员函数在修改了元素个数的时候，都必须同步更新count。 主函数、Element和Vector框架都已经给出并锁定，你不能更改它们。 样例输入 1无 样例输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ctorcopy ctordtorctorright value ctorcopy ctordtordtorctorright value ctorright value ctorcopy ctordtordtordtorctorright value ctorright value ctorright value ctorcopy ctordtordtordtordtor0 1 2 3 ctorright value ctorright value ctorcopy ctorright value ctorright value ctordtordtordtordtor0 1 4 2 3 right value ctorright value ctorright value ctorright value ctordtordtordtordtordtor0 1 2 3 ctorctor1-10 1 2 3 copy ctor1 dtordtordtordtordtordtordtordtordtordtordtordtor 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;class Element &#123;private: int number;public: Element() :number(0) &#123; cout &lt;&lt; &quot;ctor&quot; &lt;&lt; endl; &#125; Element(int num):number(num) &#123; cout &lt;&lt; &quot;ctor&quot; &lt;&lt; endl; &#125; Element(const Element&amp; e):number(e.number) &#123; cout &lt;&lt; &quot;copy ctor&quot; &lt;&lt; endl; &#125; Element(Element&amp;&amp; e):number(e.number) &#123; cout &lt;&lt; &quot;right value ctor&quot; &lt;&lt; endl; &#125; ~Element() &#123; cout &lt;&lt; &quot;dtor&quot; &lt;&lt; endl; &#125; void operator=(const Element&amp; item) &#123; number = item.number; &#125; bool operator==(const Element&amp; item) &#123; return (number == item.number); &#125; void operator()() &#123; cout &lt;&lt; number ; &#125; int GetNumber() &#123; return number; &#125;&#125;;template&lt;typename T&gt;class Vector &#123;private: T* items; int count;public: Vector() :count&#123; 0 &#125;, items&#123;nullptr&#125; &#123; &#125; Vector(const Vector&amp; vector) :count&#123;vector.count&#125; &#123; items = static_cast&lt;T*&gt;(malloc(sizeof(T) * count)); memcpy(items, vector.items, sizeof(T) * count); &#125; Vector(Vector&amp;&amp; vector) :count&#123; vector.count &#125;, items&#123; vector.items &#125; &#123; vector.items = nullptr; vector.count = 0; &#125; ~Vector() &#123; Clear(); &#125; T&amp; operator[](int index)&#123; if (index&lt;0||index&gt;=count) &#123; cout&lt;&lt;&quot;invalid index&quot;&lt;&lt;endl; return items[0]; &#125; return items[index]; &#125; int returnCount()&#123; return count; &#125; void Clear() &#123; if (count == 0) return ; for (int i = 0; i &lt; count; i++) &#123; items[i].~T(); &#125; free(items); items = nullptr; count = 0; return ; &#125; void Add(const T&amp; item) &#123; T *new_store = (T *)malloc(sizeof(T) * (count + 1)); for (int i = 0; i &lt; count; i++) &#123; new(new_store + i)T(std::move(items[i])); &#125; new(new_store + count)T(item); int pre = count + 1; Clear(); count = pre; items = new_store; return ; &#125; bool Insert(const T&amp; item,int index) &#123; if (index &lt; 0 || index &gt; count) return false; T *new_store = (T *)malloc(sizeof(T) * (count + 1)); for (int i = count - 1; i &gt;= index; i--) &#123; new(new_store + i + 1)T(std::move(items[i])); &#125; new(new_store + index)T(item); for (int i = 0; i &lt; index; i++) &#123; new(new_store + i)T(std::move(items[i])); &#125; int pre = count + 1; Clear(); count = pre; items = new_store; return true; &#125; bool Remove(int index) &#123; if (index &lt; 0 || index &gt; count) return false; T *new_store; if (count - 1) new_store = (T *)malloc(sizeof(T) * (count - 1)); else new_store = nullptr; for (int i = 0; i &lt; count; i++) &#123; if (i == index) continue; if (i &lt; index) new(new_store + i)T(std::move(items[i])); if (i &gt; index) new(new_store + i - 1)T(std::move(items[i])); &#125; int pre = count - 1; Clear(); count = pre; items = new_store; return true; &#125; int Contains(const T&amp; item) &#123; for (int i = 0; i &lt; count; i++) &#123; if (items[i] == item) return i; &#125; return -1; &#125;&#125;;template&lt;typename T&gt;void PrintVector(Vector&lt;T&gt;&amp; v)&#123; int count=v.returnCount(); for (int i = 0; i &lt; count; i++) &#123; v[i](); cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl;&#125;int main() &#123; Vector&lt;Element&gt;v; for (int i = 0; i &lt; 4; i++) &#123; Element e(i); v.Add(e); &#125; PrintVector(v); Element e2(4); if (!v.Insert(e2, 10)) &#123; v.Insert(e2, 2); &#125; PrintVector(v); if (!v.Remove(10)) &#123; v.Remove(2); &#125; PrintVector(v); Element e3(1), e4(10); cout &lt;&lt; v.Contains(e3) &lt;&lt; endl; cout &lt;&lt; v.Contains(e4) &lt;&lt; endl; Vector&lt;Element&gt;v2(v); Vector&lt;Element&gt;v3(move(v2)); PrintVector(v3); v2.Add(e3); PrintVector(v2); return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"c++线程池的实现","slug":"c++/7.线程池","date":"2020-08-13T15:08:04.111Z","updated":"2020-08-15T09:42:12.015Z","comments":true,"path":"2020/08/13/c++/7.线程池/","link":"","permalink":"http://yoursite.com/2020/08/13/c++/7.%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"一些概念 临界区资源：（多线程同时操作的操作的资源）， 任务队列 线程安全：一个资源在多线程同时操作时不出错就是安全的 非线程安全的临界资源：一个资源在多线程同时操作情况下会出现读写错误（STL基本都是非线程安全的） 线程同步： 原子操作：某一操作过程中不会插入其他操作（加锁把操） 线程池初步框架 封装任务类： 任务类中有个function对象属性、接收bind绑定的函数或函数对象 封装线程池： 三大步骤: start 启动线程池，这里面去new 给定数量的thread对象，每个线程绑定成员方法worker worker 取任务get_one_task 执行任务 释放任务 stop 回收线程、清空线程池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;thread&gt;using namespace std;/* 封装一个任务类， 通过 bind 将 方法(函数)名和参数绑定在一起, 完成一个任务的封装*/class Task &#123;public: template&lt;typename T, typename ...ARGS&gt; Task(T func, ARGS... args) &#123; //forward 使参数按照原来的类型向前传递 this-&gt;func = std::bind(func, forward&lt;ARGS&gt;(args)...); &#125; void operator()()&#123; this-&gt;func(); return ; &#125;private: function&lt;void()&gt; func;&#125;;void thread_func1(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl; return ;&#125;void thread_func2(int &amp;n) &#123; n += 1; return ;&#125;class ThreadPool &#123;public: ThreadPool(int n = 5) : is_running(false), max_threads_num(n) &#123; &#125; void start() &#123; if (is_running) return ; is_running = true; //初始化线程池对象 for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; //以成员方法作为入口, 参数不要忘记隐藏的this //正常函数传入到 thread()中，直接传入函数名即函数指针，但传入成员方法需要对方法取地址 threads.push_back(new thread(&amp;ThreadPool::worker, this)); &#125; &#125; void worker() &#123; //成员含有一个隐藏参数 this! cout &lt;&lt; &quot;worker: I am worker!&quot; &lt;&lt; endl; &#125; void stop() &#123; if (is_running == false) return ; is_running = false; for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; threads[i]-&gt;join(); delete threads[i]; &#125; threads.clear(); return ; &#125;private: bool is_running; int max_threads_num; vector&lt;thread *&gt; threads; //线程池&#125;;int main() &#123; Task t1(thread_func1, 3, 4); Task t2(thread_func1, 5, 6); Task t3(thread_func1, 9, 7); t1(), t2(), t3(); int n = 0; Task t4(thread_func2, ref(n)); t4(); t4(); t4(); cout &lt;&lt; n &lt;&lt; endl; ThreadPool tp(6); tp.start(); tp.stop(); return 0;&#125; getOneTask 和 addOneTask在 getonetask时，我们线程池的任务队列中不一定有任务、所以需要有个 addOnTask方法让主线程或其他线程去在任务队列中放任务 而任务队列是临界资源不能同时又读又取， 因此两个操作应该是原子操作， 那就需要加锁处理 第一版代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;queue&gt;#include &lt;condition_variable&gt;#include &lt;mutex&gt;using namespace std;/* 封装一个任务类， 通过 bind 将 方法(函数)名和参数绑定在一起, 完成一个任务的封装*/class Task &#123;public: template&lt;typename T, typename ...ARGS&gt; Task(T func, ARGS... args) &#123; //forward 使参数按照原来的类型向前传递 this-&gt;func = std::bind(func, forward&lt;ARGS&gt;(args)...); &#125; void operator()()&#123; this-&gt;func(); return ; &#125;private: function&lt;void()&gt; func;&#125;;class ThreadPool &#123;public: ThreadPool(int n = 5) : is_running(false), max_threads_num(n), m_mutex(), m_cond() &#123;&#125; void start() &#123; if (is_running) return ; is_running = true; //初始化线程池对象 for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; //以成员方法作为入口, 参数不要忘记隐藏的this //正常函数传入到 thread()中，直接传入函数名即函数指针，但传入成员方法需要对方法取地址 threads.push_back(new thread(&amp;ThreadPool::worker, this)); &#125; &#125; void worker() &#123; //向任务队列中取任务 //cout &lt;&lt; &quot;worker: I am worker!&quot; &lt;&lt; endl; while (is_running) &#123; //只要线程池没有停止，每个线程都会反复的执行下面三个步骤： /* 1、取任务 2、执行任务 3、释放任务 */ Task *t = this-&gt;getOneTask(); if (t == nullptr) break; (*t)(); delete t; &#125; return ; &#125; void stop() &#123; if (is_running == false) return ; //当任务都处理完毕，现在的所有线程都会处于 wait 中在等待着任务，我们此时就可以结束线程池了。 do &#123; //要结束线程池，就得先抢到锁，停止，并告诉所有等待任务的线程不要再取了。 unique_lock&lt;mutex&gt; lock(m_mutex); is_running = false; m_cond.notify_all(); &#125; while (0); //上面使用 do-while 是限定 lock 的作用域，出了&#123;&#125;会自动释放锁，好让那些 wait 的线程收到通知后在抢到锁 //下面就可以等着回收这些线程了 for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; threads[i]-&gt;join(); delete threads[i]; &#125; threads.clear(); /* //停止任务队列。 可以把任务队列清空 do &#123; unique_lock&lt;mutex&gt; lock(m_mutex); while (!task_queue.empty()) task_queue.pop(); &#125; while (0); */ return ; &#125; template&lt;typename T, typename ...ARGS&gt; void addOneTask(T func, ARGS...args) &#123; //设置为公有 unique_lock&lt;mutex&gt; lock(m_mutex); //lock构造完就占到锁了，这个局部变量释放时会自动解锁 this-&gt;task_queue.push(new Task(func, forward&lt;ARGS&gt;(args)...)); m_cond.notify_one(); //通知一次(cond + 1)，会有一个线程抢到通知 return ; &#125;private: //取任务操作设置为私有，只希望worker中调用 Task *getOneTask() &#123; unique_lock&lt;mutex&gt; lock(m_mutex); //抢碗 while (is_running &amp;&amp; task_queue.empty()) &#123; /* 判断条件如果是 if(task_queue.empty()) 会出错 因为，addOneTask 抢到 wait 释放的锁后，开始放任务，有可能连续连续抢到两次锁放了两个任务， 条件变量就会+2，就会放出两个信号让等待中的线程来接收 但此时如果新进来的线程，一进来就判断到队列不空，它就会取走一个任务，并且也没有给cond-1！ 另一个任务正常地让等待中的一个线程取到了 但是在等待信号中的另一个线程仍然可以正好收到cond大于0的信号，它会去队列取任务，殊不知任务已经 被新进来的线程取走了，于是就会出现段错误 改成while循环后，等待中的线程收到信号时它会再去判断一下队列是否为空，此时要时真不空就可以去取任务了 */ //cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot;wait to task...&quot; &lt;&lt; endl; //等待任务，直到队列中存在任务 m_cond.wait(lock); //1、添加任务可能会满足 2、stop时会满足(所以while中添加个条件) //wait: 临时释放锁并等待通知，让加任务的去抢到锁后添加任务并发个通知。这里收到通知后会再次自动抢到锁 &#125; //这下面还是拿到锁的 if (is_running == false) return nullptr; //停止了 //cout &lt;&lt; this_thread::get_id() &lt;&lt; &quot;take one task...&quot; &lt;&lt; endl; Task *t = task_queue.front(); task_queue.pop(); return t; &#125; bool is_running; int max_threads_num; vector&lt;thread *&gt; threads; //线程池 queue&lt;Task *&gt; task_queue; mutex m_mutex; condition_variable m_cond;&#125;;void task_func(int x) &#123; cout &lt;&lt; &quot;Task func&quot; &lt;&lt; x &lt;&lt; endl; return ;&#125;void thread_func1(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl; return ;&#125;void thread_func2(int &amp;n) &#123; n += 1; return ;&#125;int main() &#123; Task t1(thread_func1, 3, 4); Task t2(thread_func1, 5, 6); Task t3(thread_func1, 9, 7); t1(), t2(), t3(); int n = 0; Task t4(thread_func2, n); t4(); t4(); t4(); cout &lt;&lt; n &lt;&lt; endl; ThreadPool tp(6); tp.start(); tp.addOneTask(task_func, 126); tp.addOneTask(task_func, 532); tp.addOneTask(task_func, 798); tp.addOneTask(task_func, 100); tp.addOneTask(task_func, 989); for (int i = 0; i &lt; 1000000; i++) ; tp.stop(); return 0;&#125; 升级版线程池第一版线程池，在 stop时，有可能有的任务还没有被执行，线程池就结束了，我们在stop前加了个循环来等任务处理完。 升级版： 我们借助map把每个线程id映射为一个bool值，用is_running记录。当is_runing为真时，代表该线程正在工作。在 worker开始时我们先把该线程的is_runing置为 true 。然后在线程运行时不断的去取任务执行任务。 在 stop时我们向线程池中添加等线程数量的stop_task任务，这个任务专门把线程的 is_runing置为false，线程执行完这个任务，is_runing就变成了false也就不会再去取任务，就结束了。然后就去回收这些线程。这样能保证所有任务都能被执行完。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;#include &lt;thread&gt;#include &lt;queue&gt;#include &lt;condition_variable&gt;#include &lt;mutex&gt;using namespace std;/* 封装一个任务类， 通过 bind 将 方法(函数)名和参数绑定在一起, 完成一个任务的封装*/class Task &#123;public: template&lt;typename T, typename ...ARGS&gt; Task(T func, ARGS... args) &#123; //forward 使参数按照原来的类型向前传递 this-&gt;func = std::bind(func, forward&lt;ARGS&gt;(args)...); &#125; void operator()()&#123; this-&gt;func(); return ; &#125;private: function&lt;void()&gt; func;&#125;;class ThreadPool &#123;public: ThreadPool(int n = 5) : max_threads_num(n), m_mutex(), m_cond() &#123;&#125; void start() &#123; //初始化线程池对象 for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; threads.push_back(new thread(&amp;ThreadPool::worker, this)); &#125; &#125; void worker() &#123; thread::id id = this_thread::get_id(); is_running[id] = true; while (is_running[id]) &#123; //只要线程池没有停止，每个线程都会反复的执行下面三个步骤： /* 1、取任务 2、执行任务 3、释放任务 */ Task *t = this-&gt;getOneTask(); (*t)(); delete t; &#125; return ; &#125; void stop() &#123; for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; this-&gt;addOneTask(&amp;ThreadPool::stop_task, this); &#125; for (int i = 0; i &lt; this-&gt;max_threads_num; i++) &#123; threads[i]-&gt;join(); delete threads[i]; &#125; threads.clear(); return ; &#125; template&lt;typename T, typename ...ARGS&gt; void addOneTask(T func, ARGS...args) &#123; //设置为公有 unique_lock&lt;mutex&gt; lock(m_mutex); //lock构造完就占到锁了，这个局部变量释放时会自动解锁 this-&gt;task_queue.push(new Task(func, forward&lt;ARGS&gt;(args)...)); m_cond.notify_one(); //通知一次(cond + 1)，会有一个线程抢到通知 return ; &#125;private: void stop_task() &#123; thread::id id = this_thread::get_id(); is_running[id] = false; return; &#125; //取任务操作设置为私有，只希望worker中调用 Task *getOneTask() &#123; unique_lock&lt;mutex&gt; lock(m_mutex); //抢碗 while (task_queue.empty()) &#123; m_cond.wait(lock); &#125; Task *t = task_queue.front(); task_queue.pop(); return t; &#125; int max_threads_num; vector&lt;thread *&gt; threads; //线程池 queue&lt;Task *&gt; task_queue; map&lt;std::thread::id, bool&gt; is_running; mutex m_mutex; condition_variable m_cond;&#125;;void task_func(int x) &#123; cout &lt;&lt; &quot;Task func&quot; &lt;&lt; x &lt;&lt; endl; return ;&#125;void thread_func1(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl; return ;&#125;void thread_func2(int &amp;n) &#123; n += 1; return ;&#125;/******************统计区间内素数数量***************/int cnt = 0;int is_prime(int n) &#123; if (n &lt;= 1) return 0; for (int i = 2; i * i &lt;= n; i++) &#123; if (n % i == 0) return 0; &#125; return 1;&#125;void count_prime(int l, int r) &#123; for (int i = l; i &lt;= r; i++) &#123; if (is_prime(i)) __sync_fetch_and_add(&amp;cnt, 1); &#125; return ;&#125;int main() &#123; Task t1(thread_func1, 3, 4); Task t2(thread_func1, 5, 6); Task t3(thread_func1, 9, 7); t1(), t2(), t3(); int n = 0; Task t4(thread_func2, n); t4(); t4(); t4(); cout &lt;&lt; n &lt;&lt; endl; ThreadPool tp(6); tp.start(); tp.addOneTask(task_func, 126); tp.addOneTask(task_func, 532); tp.addOneTask(task_func, 798); tp.addOneTask(task_func, 100); tp.addOneTask(task_func, 989); tp.stop(); tp.addOneTask(task_func, 100); tp.addOneTask(task_func, 100); tp.addOneTask(task_func, 100); /*************用多线程处理任务****************/ ThreadPool tp2(5); tp2.start(); for (int i = 0, j = 1; i &lt; 5; i++, j += 200000) &#123; tp2.addOneTask(count_prime, j, j + 200000 - 1); &#125; tp2.stop(); cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; 多线程统计1-1000000内素数数量看升级版代码177行 我们设置了一个全局变量 cnt, 在统计素数个数的函数中我们操作它、很明显它是一个临界资源，需要加锁 __sync_fetch_and_add __sync_fetch_and_add系列一共有十二个函数，有加/减/与/或/异或/等函数的原子性操作函数 加上__sync_fetch_and_add对cnt的操作就变成原子操作了， 看代码142行","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"模板","slug":"c++/6.模板","date":"2020-08-13T06:03:39.274Z","updated":"2020-08-14T01:13:35.237Z","comments":true,"path":"2020/08/13/c++/6.模板/","link":"","permalink":"http://yoursite.com/2020/08/13/c++/6.%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"基本概念 程序 = 算法 + 数据结构 数据结构：能够存储任意类型 算法：能够操作 存储任意类型数据的 数据结构 泛型编程： 将任意类型从程序中抽象出来 模板 模板和宏有一些类似，它们都是编译期确定的，运行时就已经没有模板了， 模板在编译时已经实例化成了具体的函数 使用 nm -C test.o 或 nm -C a.out 可以查看 test中或 a.out中已经定义的文件 源代码———(预处理)———&gt; 编译 ———(生成目标文件，已不存在模板)———&gt; 链接 —————–&gt; 可执行文件 在链接阶段，编译器会合并相同的模板方法或模板类 模板函数 1234template&lt;typename T&gt;T add(T a, T b) &#123; return a + b;&#125; 模板类 12345678template&lt;typename T&gt;struct Print &#123; Print(std::ostream &amp;out) : out(out) &#123;&#125; void operator()(const T &amp;a) &#123; out &lt;&lt; a; &#125; std::ostream &amp;out;&#125;; 模板类+模板函数 123456789101112template&lt;typename T&gt;struct Print &#123; template&lt;typename U&gt; void operator()(const U &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; this-&gt;__temp &lt;&lt; endl; &#125; void set(const T &amp;temp) &#123; this-&gt;__temp = temp; &#125; T __temp;&#125;; 模板特化 模板的偏特化只是部分类型确定 可变参数模板 decltype进行表达式类型的推导，详细看第一版代码第 29 行 模板参数类型推导正常类型推导 隐式转换 显示转换 模板函数作为参数，传递时的间接类型推导（详细看四版代码132行） 引用类型推导☆假如有模板函数 T add(T &amp;&amp;a, T &amp;&amp;b) 一般我们认为这两个参数传递的是右值引用， 但是 在模板中 这并不是右值引用，只能说明 a b 是引用类型！因为此时并不能确定 T的类型，但可以确定的知道 他们是引用！ 此时就要看调用这个方法时，我们传入的参数具体是左值还是右值，以整数为例 如果我们传进去的是左值，那么 T 的类型就是左值引用，模板函数变为int&amp; add(int &amp;&amp;&amp;a, int &amp;&amp;&amp;b) 如果我们传进去的是左值，那么 T 的类型就是左值引用，模板函数变为int&amp;&amp; add(int &amp;&amp;&amp;&amp;a, int &amp;&amp;&amp;&amp;b) 这么多 &amp; ? 这就是 引用折叠 模板中，奇数个 &amp; 是左值引用， 偶数个 &amp; 是 右值引用，编译器会去掉多余的 &amp; 只保留一个或两个 标准类型转换如果 函数体int&amp; add(int &amp;a, int &amp;b) &#123; return a + b &#125;， a + b是一个右值，而返回值类型是 int &amp;, 右值不可能绑定到左值引用上的 系统中的一些类型转换模板就起到了作用 remove_reference&lt;T&gt; 模板类就可以 把 T 中的引用去掉把 T 变成 一个普通的类型，我们就可以在 T 上使用这个模板类 add_const 添加 const限定 remove_point 去掉指针类型 ….. 在第四版代码中进行了实现 move函数实现move是将变量类型强制转换成右值引用 我们就可以使用 add_rvalue_reference&lt;T&gt; 来实现它，看第四版代码 第一版: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A &#123;public: A(int x) : x(x) &#123;&#125; int x;&#125;;class B &#123;public: B(int y) : y(y) &#123;&#125; int y;&#125;;int operator+(const A &amp;a, const B &amp;b) &#123; return a.x + b.y;&#125;namespace haizei &#123;/*********************函数模板+特化+偏特化+返回值后置*****************************/template&lt;typename T, typename U&gt;//decltype(T() + U()) add(T a, U b ) &#123;// 当T 和 U 没有默认的构造函数的时候就会报错，下面这样写就解决了（将返回值后置）auto add(T a, U b ) -&gt; decltype(a + b) &#123; return a + b;&#125;//特化函数模板template&lt;&gt;int add(int a, int b) &#123; cout &lt;&lt; &quot;add int : &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return a + b;&#125;//偏特化函数模板template&lt;typename T, typename U&gt;auto add(T *a, U *b) -&gt; decltype(*a + *b) &#123; return add(*a, *b); //防止a, b是多重指针&#125;/************************************************************************************//*****用返回值后置完善标准库中的 max 和 min ***************************************/template&lt;typename T, typename U&gt;auto max(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? b : a);&#125;template&lt;typename T, typename U&gt;auto min(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? a : b);&#125;/********************************************************************************/ class PrintAny &#123;public: template&lt;typename T&gt; void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;&#125;;/*****************类模板和类模板特化**********************/template&lt;typename T&gt;class FoolPrintAny &#123;public: void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; &#125;;template&lt;&gt; //特化class FoolPrintAny&lt;int&gt; &#123;public: void operator()(const int &amp;a) &#123; cout &lt;&lt; &quot;naughty : &quot; &lt;&lt; 2 * a &lt;&lt; endl; &#125; &#125;;/******************************************************///**************************************变参函数模板*************/template&lt;typename T&gt; //变参模板函数边界，这个放上面void printAny(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return ;&#125;template&lt;typename T, typename ...ARGS&gt;void printAny(const T &amp;a, ARGS...args) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; printAny(args...); return ;&#125;/***************************************************************///****************************实现ARG（解析变参列表的类模板）***************template&lt;typename T, typename ...ARGS&gt;struct ARG &#123; typedef T __type; typedef ARG&lt;ARGS...&gt; __rest;&#125;;template&lt;typename T&gt;struct ARG&lt;T&gt; &#123; typedef T __type;&#125;;//***************************************************************************//变参模板类//设计一个模板类ARG来解析变参类型template&lt;typename T, typename ...ARGS&gt; class Test;template&lt;typename T, typename ...ARGS&gt; //Test的偏特化class Test&lt;T(ARGS...)&gt; &#123;public: T operator()( typename ARG&lt;ARGS...&gt;::__type a, //typename 为了避免语义歧义，说明后面的__type是个类型，是模板类中的内置类型 typename ARG&lt;ARGS...&gt;::__rest::__type b) &#123; return a + b; &#125;&#125;;&#125; //end of haizei::int main() &#123; A a(1000); B b(646); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; haizei::add(a, b) &lt;&lt; endl; cout &lt;&lt; haizei::add(4, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.2, 3.6) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(3, 4.5) &lt;&lt; endl; //max也是模板实现的, 但是标准库中的max只支持两种同类型参数 cout &lt;&lt; haizei::max(4, 5) &lt;&lt; endl; cout &lt;&lt; haizei::max(4.6, 3) &lt;&lt; endl; cout &lt;&lt; haizei::max(55, 88.8) &lt;&lt; endl; cout &lt;&lt; haizei::min(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::min(55, 88.8) &lt;&lt; endl; haizei::PrintAny print; print(123); print(56456); print(554.2); print(&quot;hello world&quot;); print(&quot;hello haizei&quot;); print(&amp;a); haizei::FoolPrintAny&lt;string&gt; f; f(&quot;hello world&quot;); haizei::FoolPrintAny&lt;int&gt; f2; //特化模板类 f2(123); int n = 45, m = 57; int *p = &amp;n, *q = &amp;m; cout &lt;&lt; haizei::add(n, m) &lt;&lt; endl; //调用特化函数模板 cout &lt;&lt; haizei::add(p, q) &lt;&lt; endl; haizei::printAny(123, 34.5, &quot;hello world&quot;, &amp;a); haizei::Test&lt;int(int, int)&gt; f3; cout &lt;&lt; f3(3, 4) &lt;&lt; endl; return 0;&#125; 第二版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A &#123;public: A(int x) : x(x) &#123;&#125; int x;&#125;;class B &#123;public: B(int y) : y(y) &#123;&#125; int y;&#125;;int operator+(const A &amp;a, const B &amp;b) &#123; return a.x + b.y;&#125;namespace haizei &#123;template&lt;typename T, typename U&gt;//decltype(T() + U()) add(T a, U b ) &#123;// 当T 和 U 没有默认的构造函数的时候就会报错，下面这样写就解决了auto add(T a, U b ) -&gt; decltype(a + b) &#123; return a + b;&#125;//特化函数模板template&lt;&gt;int add(int a, int b) &#123; cout &lt;&lt; &quot;add int : &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return a + b;&#125;//偏特化函数模板template&lt;typename T, typename U&gt;auto add(T *a, U *b) -&gt; decltype(*a + *b) &#123; return add(*a, *b); //防止a, b是多重指针&#125;template&lt;typename T, typename U&gt;auto max(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? b : a);&#125;template&lt;typename T, typename U&gt;auto min(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? a : b);&#125; class PrintAny &#123;public: template&lt;typename T&gt; void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;&#125;;template&lt;typename T&gt;class FoolPrintAny &#123;public: void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; &#125;;template&lt;&gt;class FoolPrintAny&lt;int&gt; &#123;public: void operator()(const int &amp;a) &#123; cout &lt;&lt; &quot;naughty : &quot; &lt;&lt; 2 * a &lt;&lt; endl; &#125; &#125;;//变参模板函数template&lt;typename T&gt; //变参模板函数边界，这个放上面void printAny(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return ;&#125;template&lt;typename T, typename ...ARGS&gt;void printAny(const T &amp;a, ARGS...args) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; printAny(args...); return ;&#125;//****************************实现ARG（解析变参列表的类模板）***************//n 是编译期常量，因为模板在运行期就没了，在运行期输入n就对应不上模板template&lt;int n, typename T, typename ...ARGS&gt;struct ARG &#123; typedef typename ARG&lt;n - 1, ARGS...&gt;::__type __type;&#125;;template&lt;typename T, typename ...ARGS&gt;struct ARG&lt;0, T, ARGS...&gt; &#123; typedef T __type;&#125;;template&lt;typename T&gt;struct ARG&lt;0, T&gt; &#123; typedef T __type;&#125;;//***************************************************************************//变参模板类//设计一个模板类ARG来解析变参类型template&lt;typename T, typename ...ARGS&gt; class Test;template&lt;typename T, typename ...ARGS&gt; //Test的偏特化class Test&lt;T(ARGS...)&gt; &#123;public: T operator()( typename ARG&lt;0, ARGS...&gt;::__type a, typename ARG&lt;1, ARGS...&gt;::__type b ) &#123; return a + b; &#125;&#125;;&#125;int main() &#123; A a(1000); B b(646); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; haizei::add(a, b) &lt;&lt; endl; cout &lt;&lt; haizei::add(4, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.2, 3.6) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(3, 4.5) &lt;&lt; endl; //max也是模板实现的, 但是标准库中的max只支持两种同类型参数 cout &lt;&lt; haizei::max(4, 5) &lt;&lt; endl; cout &lt;&lt; haizei::max(4.6, 3) &lt;&lt; endl; cout &lt;&lt; haizei::max(55, 88.8) &lt;&lt; endl; cout &lt;&lt; haizei::min(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::min(55, 88.8) &lt;&lt; endl; haizei::PrintAny print; print(123); print(56456); print(554.2); print(&quot;hello world&quot;); print(&quot;hello haizei&quot;); print(&amp;a); haizei::FoolPrintAny&lt;string&gt; f; f(&quot;hello world&quot;); haizei::FoolPrintAny&lt;int&gt; f2; //特化模板类 f2(123); int n = 45, m = 57; int *p = &amp;n, *q = &amp;m; cout &lt;&lt; haizei::add(n, m) &lt;&lt; endl; //调用特化模板函数 cout &lt;&lt; haizei::add(p, q) &lt;&lt; endl; haizei::printAny(123, 34.5, &quot;hello world&quot;, &amp;a); haizei::Test&lt;int(int, int)&gt; f3; cout &lt;&lt; f3(3, 4) &lt;&lt; endl; return 0;&#125; 第三版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184class A &#123;public: A(int x) : x(x) &#123;&#125; int x;&#125;;class B &#123;public: B(int y) : y(y) &#123;&#125; int y;&#125;;int operator+(const A &amp;a, const B &amp;b) &#123; return a.x + b.y;&#125;namespace haizei &#123;template&lt;typename T, typename U&gt;//decltype(T() + U()) add(T a, U b ) &#123;// 当T 和 U 没有默认的构造函数的时候就会报错，下面这样写就解决了auto add(T a, U b ) -&gt; decltype(a + b) &#123; return a + b;&#125;//特化函数模板template&lt;&gt;int add(int a, int b) &#123; cout &lt;&lt; &quot;add int : &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return a + b;&#125;//偏特化函数模板template&lt;typename T, typename U&gt;auto add(T *a, U *b) -&gt; decltype(*a + *b) &#123; return add(*a, *b); //防止a, b是多重指针&#125;template&lt;typename T, typename U&gt;auto max(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? b : a);&#125;template&lt;typename T, typename U&gt;auto min(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? a : b);&#125; class PrintAny &#123;public: template&lt;typename T&gt; void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;&#125;;template&lt;typename T&gt;class FoolPrintAny &#123;public: void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; &#125;;template&lt;&gt;class FoolPrintAny&lt;int&gt; &#123;public: void operator()(const int &amp;a) &#123; cout &lt;&lt; &quot;naughty : &quot; &lt;&lt; 2 * a &lt;&lt; endl; &#125; &#125;;//变参模板函数template&lt;typename T&gt; //变参模板函数边界，这个放上面void printAny(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return ;&#125;template&lt;typename T, typename ...ARGS&gt;void printAny(const T &amp;a, ARGS... args) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; printAny(args...); return ;&#125;//****************************实现ARG（解析变参列表的类模板）***************template&lt;int n, typename T, typename ...ARGS&gt;struct ARG &#123; typedef typename ARG&lt;n - 1, ARGS...&gt;::__type __type;&#125;;template&lt;typename T, typename ...ARGS&gt;struct ARG&lt;0, T, ARGS...&gt; &#123; typedef T __type;&#125;;template&lt;typename T&gt;struct ARG&lt;0, T&gt; &#123; typedef T __type;&#125;;//***************************************************************************//变参模板类//设计一个模板类ARG来解析变参类型template&lt;typename T, typename ...ARGS&gt; class Test;template&lt;typename T, typename ...ARGS&gt; //Test的偏特化class Test&lt;T(ARGS...)&gt; &#123;public: T operator()(ARGS... args) &#123; return add&lt;T&gt;(args...); &#125;private: template&lt;typename T1, typename U, typename ...US&gt; T1 add(U a, US... args) &#123; return a + add&lt;T&gt;(args...); &#125; template&lt;typename T1, typename U&gt; T1 add(U a) &#123; return a; &#125;&#125;;&#125;int main() &#123; A a(1000); B b(646); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; haizei::add(a, b) &lt;&lt; endl; cout &lt;&lt; haizei::add(4, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.2, 3.6) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(3, 4.5) &lt;&lt; endl; //max也是模板实现的, 但是标准库中的max只支持两种同类型参数 cout &lt;&lt; haizei::max(4, 5) &lt;&lt; endl; cout &lt;&lt; haizei::max(4.6, 3) &lt;&lt; endl; cout &lt;&lt; haizei::max(55, 88.8) &lt;&lt; endl; cout &lt;&lt; haizei::min(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::min(55, 88.8) &lt;&lt; endl; haizei::PrintAny print; print(123); print(56456); print(554.2); print(&quot;hello world&quot;); print(&quot;hello haizei&quot;); print(&amp;a); haizei::FoolPrintAny&lt;string&gt; f; f(&quot;hello world&quot;); haizei::FoolPrintAny&lt;int&gt; f2; //特化模板类 f2(123); int n = 45, m = 57; int *p = &amp;n, *q = &amp;m; cout &lt;&lt; haizei::add(n, m) &lt;&lt; endl; //调用特化模板函数 cout &lt;&lt; haizei::add(p, q) &lt;&lt; endl; haizei::printAny(123, 34.5, &quot;hello world&quot;, &amp;a); haizei::Test&lt;int(int, int)&gt; f3; cout &lt;&lt; f3(3, 4) &lt;&lt; endl; haizei::Test&lt;int(int, int, int, int)&gt; f4; //()外的int是返回值类型 cout &lt;&lt; f4(1, 2, 3, 4) &lt;&lt; endl; //累加求和 haizei::Test&lt;int(int, int, int, int, int)&gt; f5; cout &lt;&lt; f5(1, 2, 3, 4, 5) &lt;&lt; endl; //累加求和 return 0;&#125; 第四版: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255class A &#123;public: A(int x) : x(x) &#123;&#125; int x;&#125;;class B &#123;public: B(int y) : y(y) &#123;&#125; int y;&#125;;int operator+(const A &amp;a, const B &amp;b) &#123; return a.x + b.y;&#125;namespace haizei &#123;template&lt;typename T, typename U&gt;//decltype(T() + U()) add(T a, U b ) &#123;// 当T 和 U 没有默认的构造函数的时候就会报错，下面这样写就解决了auto add(T a, U b ) -&gt; decltype(a + b) &#123; return a + b;&#125;//特化函数模板template&lt;&gt;int add(int a, int b) &#123; cout &lt;&lt; &quot;add int : &quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return a + b;&#125;//偏特化函数模板template&lt;typename T, typename U&gt;auto add(T *a, U *b) -&gt; decltype(*a + *b) &#123; return add(*a, *b); //防止a, b是多重指针&#125;template&lt;typename T, typename U&gt;auto max(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? b : a);&#125;template&lt;typename T, typename U&gt;auto min(T a, U b) -&gt; decltype(a + b) &#123; return (a &lt; b ? a : b);&#125; class PrintAny &#123;public: template&lt;typename T&gt; void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125;&#125;;template&lt;typename T&gt;class FoolPrintAny &#123;public: void operator()(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; endl; &#125; &#125;;template&lt;&gt;class FoolPrintAny&lt;int&gt; &#123;public: void operator()(const int &amp;a) &#123; cout &lt;&lt; &quot;naughty : &quot; &lt;&lt; 2 * a &lt;&lt; endl; &#125; &#125;;//变参模板函数template&lt;typename T&gt; //变参模板函数边界，这个放上面void printAny(const T &amp;a) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; endl; return ;&#125;template&lt;typename T, typename ...ARGS&gt;void printAny(const T &amp;a, ARGS... args) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot;; printAny(args...); return ;&#125;//****************************实现ARG（解析变参列表的类模板）***************template&lt;int n, typename T, typename ...ARGS&gt;struct ARG &#123; typedef typename ARG&lt;n - 1, ARGS...&gt;::__type __type;&#125;;template&lt;typename T, typename ...ARGS&gt;struct ARG&lt;0, T, ARGS...&gt; &#123; typedef T __type;&#125;;template&lt;typename T&gt;struct ARG&lt;0, T&gt; &#123; typedef T __type;&#125;;//***************************************************************************//变参模板类//设计一个模板类ARG来解析变参类型template&lt;typename T, typename ...ARGS&gt; class Test;template&lt;typename T, typename ...ARGS&gt; //Test的偏特化class Test&lt;T(ARGS...)&gt; &#123;public: T operator()(ARGS... args) &#123; return add&lt;T&gt;(args...); &#125;private: template&lt;typename T1, typename U, typename ...US&gt; T1 add(U a, US... args) &#123; return a + add&lt;T&gt;(args...); &#125; template&lt;typename T1, typename U&gt; T1 add(U a) &#123; return a; &#125;&#125;;/**************模板函数作为参数传递时，自动类型推导**/template&lt;typename T, typename U&gt;T test_param_func(U a) &#123; return T(a * 2);&#125;void func2(int (*func)(double)) &#123; cout &lt;&lt; func(2.3) &lt;&lt; endl;&#125;/*****************************************************//*************************标准类型转换模板************************///remove_reference模板类将T的引用去掉，变成普通的类型template&lt;typename T&gt; struct remove_reference &#123; typedef T type; &#125;;template&lt;typename T&gt; struct remove_reference&lt;T &amp;&gt; &#123; typedef T type; &#125;;template&lt;typename T&gt; struct remove_reference&lt;T &amp;&amp;&gt; &#123; typedef T type; &#125;;// add_consttemplate&lt;typename T&gt; struct add_const &#123; typedef const T type; &#125;;template&lt;typename T&gt; struct add_const&lt;const T&gt; &#123; typedef const T type; &#125;;// add_lvalue_referencetemplate&lt;typename T&gt; struct add_lvalue_reference &#123; typedef T &amp;type; &#125;;template&lt;typename T&gt; struct add_lvalue_reference&lt;T &amp;&gt; &#123; typedef T &amp;type; &#125;;template&lt;typename T&gt; struct add_lvalue_reference&lt;T &amp;&amp;&gt; &#123; typedef T &amp;type; &#125;;// add_rvalue_referencetemplate&lt;typename T&gt; struct add_rvalue_reference &#123; typedef T&amp;&amp; type; &#125;;template&lt;typename T&gt; struct add_rvalue_reference&lt;T &amp;&gt; &#123; typedef T&amp;&amp; type; &#125;;template&lt;typename T&gt; struct add_rvalue_reference&lt;T &amp;&amp;&gt; &#123; typedef T&amp;&amp; type; &#125;;// add_lvalue_referencetemplate&lt;typename T&gt; struct remove_pointer &#123; typedef T type; &#125;;template&lt;typename T&gt; struct remove_pointer&lt;T *&gt; &#123; typedef typename remove_pointer&lt;T&gt;::type type; &#125;;//move 函数的实现template&lt;typename T&gt;typename add_rvalue_reference&lt;T&gt;::type move(T &amp;&amp;a) &#123; return typename add_rvalue_reference&lt;T&gt;::type(a);&#125;void f(int &amp;x) &#123; cout &lt;&lt; &quot;f : left value&quot; &lt;&lt; endl; return ;&#125;void f(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;f : right value&quot; &lt;&lt; endl; return ;&#125;template&lt;typename T&gt;typename remove_reference&lt;T&gt;::type add2(T &amp;&amp;a, T &amp;&amp;b) &#123; typename remove_reference&lt;T&gt;::type c = a + b; return c;&#125;/***********************************************************************/&#125; // END OF haizeiint main() &#123; int inta = 123, intb = 456; cout &lt;&lt; haizei::add2(inta, intb) &lt;&lt; endl; cout &lt;&lt; haizei::add2(123, 456) &lt;&lt; endl; haizei::func2(haizei::test_param_func); A a(1000); B b(646); cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; haizei::add(a, b) &lt;&lt; endl; cout &lt;&lt; haizei::add(4, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.2, 3.6) &lt;&lt; endl; cout &lt;&lt; haizei::add(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::add(3, 4.5) &lt;&lt; endl; //max也是模板实现的, 但是标准库中的max只支持两种同类型参数 cout &lt;&lt; haizei::max(4, 5) &lt;&lt; endl; cout &lt;&lt; haizei::max(4.6, 3) &lt;&lt; endl; cout &lt;&lt; haizei::max(55, 88.8) &lt;&lt; endl; cout &lt;&lt; haizei::min(4.5, 3) &lt;&lt; endl; cout &lt;&lt; haizei::min(55, 88.8) &lt;&lt; endl; haizei::PrintAny print; print(123); print(56456); print(554.2); print(&quot;hello world&quot;); print(&quot;hello haizei&quot;); print(&amp;a); haizei::FoolPrintAny&lt;string&gt; f; f(&quot;hello world&quot;); haizei::FoolPrintAny&lt;int&gt; f2; //特化模板类 f2(123); int n = 45, m = 57; int *p = &amp;n, *q = &amp;m; cout &lt;&lt; haizei::add(n, m) &lt;&lt; endl; //调用特化模板函数 cout &lt;&lt; haizei::add(p, q) &lt;&lt; endl; haizei::printAny(123, 34.5, &quot;hello world&quot;, &amp;a); haizei::Test&lt;int(int, int)&gt; f3; cout &lt;&lt; f3(3, 4) &lt;&lt; endl; haizei::Test&lt;int(int, int, int, int)&gt; f4; //()外的int是返回值类型 cout &lt;&lt; f4(1, 2, 3, 4) &lt;&lt; endl; //累加求和 haizei::Test&lt;int(int, int, int, int, int)&gt; f5; cout &lt;&lt; f5(1, 2, 3, 4, 5) &lt;&lt; endl; //累加求和 //move函数测试 haizei::f(n); haizei::f(haizei::move(n)); //cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; function类模板 std::function 是通用多态函数封装器。 std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针。 12template&lt; class R, class... Args &gt;class function&lt;R(Args...)&gt;; 使用看链接 function的实现实现 function 思路： 首先 function 可以接收普通函数也可以接收函数对象，所以就要实现一个 抽象类 base，用来把普通函数和函数对象的类封装成一个类，并重载 ()， 后面ptr好调用，也就是统一成一个函数对象 并实现一个子类normal_func去具体封装普通函数，再实现一个子类functor封装已存在的函数对象. 子类具体实现看代码 这样我们在 function 中定义一个成员属性 - base 类型的指针 ptr，并去实现两个有参构造函数(转换构造)，一个是把normal_func的对象赋值给 ptr 一个把functor的对象赋给 ptr。 然后还需要在function类中重载 (), 里面我们调用 ptr指向的函数对象的 () 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;namespace haizei &#123;template&lt;typename RT, typename ...PARAMS&gt; class base&#123;public: virtual RT operator()(PARAMS...) = 0; virtual ~base() &#123;&#125;&#125;;template&lt;typename RT, typename ...PARAMS&gt; class normal_func : public base&lt;RT, PARAMS...&gt;&#123;public: typedef RT (*func_type)(PARAMS...); normal_func(func_type func) : ptr(func) &#123;&#125; virtual RT operator()(PARAMS... args) override &#123; return this-&gt;ptr(args...); &#125;private: func_type ptr;&#125;;template&lt;typename C, typename RT, typename ...PARAMS&gt; class functor : public base&lt;RT, PARAMS...&gt;&#123;public: functor(C &amp;func) : ptr(func) &#123;&#125; virtual RT operator()(PARAMS... args) override &#123; return this-&gt;ptr(args...); &#125;private: C &amp;ptr;&#125;;//RT：返回值类型template&lt;typename RT, typename ...PARAMS&gt; class function;template&lt;typename RT, typename ...PARAMS&gt;class function&lt;RT(PARAMS...)&gt; &#123;public: function(RT (*func)(PARAMS...)) : ptr(new normal_func&lt;RT, PARAMS...&gt;(func)) &#123;&#125; //普通函数 template&lt;typename T&gt; function(T &amp;&amp;a) : ptr(new functor&lt;typename remove_reference&lt;T&gt;::type, RT, PARAMS...&gt;(a))&#123;&#125; //函数对象 RT operator()(PARAMS... args) &#123; return this-&gt;ptr-&gt;operator()(args...); &#125; ~function() &#123; delete ptr; &#125;private: base&lt;RT, PARAMS...&gt; *ptr;&#125;;&#125; //end of haizei;void f(function&lt;int(int, int)&gt; g) &#123; cout &lt;&lt; g(3, 4) &lt;&lt; endl; return ;&#125;int add(int a, int b) &#123; return a + b;&#125;struct MaxClass &#123; int operator()(int a, int b) &#123; return a &gt; b ? a : b; &#125;&#125;;/************************统计函数执行次数********************************/class FunctionCnt &#123;public: FunctionCnt(function&lt;int(int, int)&gt; g) : g(g), __cnt(0) &#123;&#125; int operator() (int a, int b) &#123; __cnt += 1; return g(a, b); &#125; int cnt() &#123; return __cnt; &#125;private: function&lt;int(int, int)&gt; g; int __cnt;&#125;;/******************************************************************************/int main() &#123; MaxClass max; f(add); f(max); haizei::function&lt;int(int, int)&gt; g1(add); haizei::function&lt;int(int, int)&gt; g2(max); cout &lt;&lt; g1(3, 4) &lt;&lt; endl; cout &lt;&lt; g2(3, 4) &lt;&lt; endl; FunctionCnt add_cnt(add); add_cnt(3, 4); add_cnt(5, 6); add_cnt(4, 8); cout &lt;&lt; add_cnt.cnt() &lt;&lt; endl; return 0;&#125; 统计函数执行的次数上一个代码实现了具体类型的统计函数执行次数的类， 这次用模板去实现 在使用自己实现的function来统计遇到了一个***的小问题，具体看代码注释（从146行开始看） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;namespace haizei &#123;template&lt;typename RT, typename ...PARAMS&gt; class base &#123;public: virtual RT operator()(PARAMS...) = 0; virtual base&lt;RT, PARAMS...&gt; *getCopy() = 0; virtual ~base() &#123;&#125;&#125;;//把函数抽象为另一个函数对象的类的实现template&lt;typename RT, typename ...PARAMS&gt; class normal_func : public base&lt;RT, PARAMS...&gt;&#123;public: typedef RT (*func_type)(PARAMS...); //函数指针 normal_func(func_type func) : ptr(func) &#123;&#125; virtual RT operator()(PARAMS... args) override &#123; return this-&gt;ptr(args...); &#125; virtual base&lt;RT, PARAMS...&gt; *getCopy() override &#123; return new normal_func&lt;RT, PARAMS...&gt;(ptr); &#125;private: func_type ptr;&#125;;//函数对象类模板template&lt;typename C, typename RT, typename ...PARAMS&gt; class functor : public base&lt;RT, PARAMS...&gt;&#123;public: functor(C &amp;func) : ptr(func) &#123;&#125; virtual RT operator()(PARAMS... args) override &#123; return this-&gt;ptr(args...); &#125; virtual base&lt;RT, PARAMS...&gt; *getCopy() override &#123; return new functor&lt;C, RT, PARAMS...&gt;(ptr); &#125;private: C &amp;ptr;&#125;;template&lt;typename RT, typename ...PARAMS&gt; class function; //RT：返回值类型, PARAMS...:变参列表template&lt;typename RT, typename ...PARAMS&gt;class function&lt;RT(PARAMS...)&gt; &#123;public: function(RT (*func)(PARAMS...)) : ptr(new normal_func&lt;RT, PARAMS...&gt;(func)) &#123;&#125; //普通函数 template&lt;typename T&gt; function(T a) : ptr(new functor&lt;typename remove_reference&lt;T&gt;::type, RT, PARAMS...&gt;(a))&#123;&#125; //函数对象 function(const function &amp;f) &#123; //普通拷贝构造 /* 在实现左值这个深拷贝时, 我们并不知道f.ptr的类型是普通的函数还是函数对象，这样很难开辟空间实现深拷贝 妙招：我们在base类中声明一个拷贝自己的纯虚函数，让子类实现这个方法并返回一个base类型的指针， 让左值引用的形参f来调用这个方法， 用this的ptr来接收返回值，这样就不用关心 f 中的ptr具体是 什么类型了。 */ this-&gt;ptr = f.ptr-&gt;getCopy(); &#125; function(function &amp;&amp;f) &#123; //移动构造函数 this-&gt;ptr = f.ptr; f.ptr = nullptr; &#125; RT operator()(PARAMS... args) &#123; return this-&gt;ptr-&gt;operator()(args...); &#125; ~function() &#123; if(ptr != nullptr) delete ptr; &#125;private: base&lt;RT, PARAMS...&gt; *ptr; //“ 函数对象(把函数对象和函数都抽象化为另一个函数对象)” 的指针&#125;;&#125; //end of haizei;void f(function&lt;int(int, int)&gt; g) &#123; cout &lt;&lt; g(3, 4) &lt;&lt; endl; return ;&#125;int add(int a, int b) &#123; return a + b;&#125;double add2(int a, double b, float c) &#123; return a + b + c;&#125;void print() &#123; cout &lt;&lt; &quot;hello world!&quot; &lt;&lt; endl; return ;&#125;struct MaxClass &#123; int operator()(int a, int b) &#123; return a &gt; b ? a : b; &#125;&#125;;/* //使用系统的function统计template&lt;typename T, typename ...ARGS&gt; class FunctionCnt; template&lt;typename T, typename ...ARGS&gt; class FunctionCnt&lt;T(ARGS...)&gt; &#123;public: FunctionCnt() : __cnt(0) &#123;&#125; FunctionCnt(function&lt;T(ARGS...)&gt; g) : g(g), __cnt(0) &#123;&#125; T operator()(ARGS... args) &#123; __cnt += 1; return g(args...); &#125; int cnt() &#123; return __cnt; &#125;private: function&lt;T(ARGS...)&gt; g; int __cnt;&#125;;*///使用自己实现的function来统计template&lt;typename T, typename ...ARGS&gt; class FunctionCnt;template&lt;typename T, typename ...ARGS&gt;class FunctionCnt&lt;T(ARGS...)&gt; &#123;public: FunctionCnt(haizei::function&lt;T(ARGS...)&gt; g) : g(g), __cnt(0) &#123;&#125; /* 如果传入的是haizei::function, 将自己的对象g拷贝给系统的会出现段错误， 原因是： 执行初始化列表g(g)时调用的是系统function的转换构造函数（只有一个参数的有参构造）： template&lt;class F&gt; function(F f); 在执行转换构造时，发现形参是一个我们具体function的对象（而不是引用）， 这时就会发生我们function类的拷贝构造，把我们传入的 g 拷贝一份给 f 但是在上一个代码中我们的function中没有写拷贝构造，他就会默认执行浅拷贝，因此会发生段错误 我们就需要在 function 中写一个普通拷贝构造和一个移动拷贝构造 */ T operator()(ARGS... args) &#123; __cnt += 1; return g(args...); &#125; int cnt() &#123; return __cnt; &#125;private: //haizei::function&lt;T(ARGS...)&gt; g; function&lt;T(ARGS...)&gt; g; int __cnt;&#125;;int main() &#123; MaxClass max; f(add); f(max); haizei::function&lt;int(int, int)&gt; g1(add); haizei::function&lt;int(int, int)&gt; g2(max); cout &lt;&lt; g1(3, 4) &lt;&lt; endl; cout &lt;&lt; g2(3, 4) &lt;&lt; endl; FunctionCnt&lt;int(int, int)&gt; add_cnt(add); add_cnt(3, 4); add_cnt(5, 6); add_cnt(4, 8); cout &lt;&lt; add_cnt.cnt() &lt;&lt; endl; FunctionCnt&lt;double(int, double, float)&gt; add2_cnt(add2); add2_cnt(3.5, 66, 53.1); add2_cnt(3.87, 22, 7.1); add2_cnt(66.57, 23, 9.3); add2_cnt(78.1, 88, 8.3); add2_cnt(96.36, 51, 99.31); cout &lt;&lt; add2_cnt.cnt() &lt;&lt; endl; FunctionCnt&lt;void()&gt; print_cnt(print); print_cnt(); print_cnt(); print_cnt(); print_cnt(); print_cnt(); print_cnt(); cout &lt;&lt; print_cnt.cnt() &lt;&lt; endl; return 0;&#125; bind绑定函数和参数，第一个参数是 函数名字，后面的指定实际传入参数对应到函数形参中位置或具体参数变量或值。 可以用一个function对象来接收 bind可以实现对函数或方法与参数的封装、、、 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;functional&gt;using namespace std;int add(int a, int b) &#123; cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl; return a + b;&#125;int add2(int a, int b, int c) &#123; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; c &lt;&lt; endl; return a + b;&#125;int add_cnt(function&lt;int(int, int)&gt; func, int &amp;n, int a, int b) &#123; n += 1; return func(a, b);&#125;int main() &#123; //从一种传参形式的函数变成另一种传参函数 //bind是模板方法 // placeholders::_1 代表传参（）中的第一个参数 // placeholders::_2 代表传参中的第二个参数 function&lt;int(int)&gt; f1 = bind(add, 5, placeholders::_1); f1(3), f1(4), f1(5); function&lt;int(int, int)&gt; f2 = bind(add, placeholders::_2, placeholders::_1); f2(3, 4), f2(5, 6), f2(7, 8); function&lt;int(int, int)&gt; f3 = bind(add2, placeholders::_2, 6, placeholders::_1); f3(9, 10); function&lt;int(int, int, int)&gt; f4 = bind(add2, placeholders::_1, placeholders::_3, placeholders::_2); f4(1, 2, 3); //绑定一个可以统计函数执行次数的方法 int n = 0; /* 因为 bind 是模板方法，我们在传第二个参数时，它并不知道 n 是一个引用，它会拷贝一个 n 给 add_cnt 的第二个 参数 n, 因此统计函数执行次数时输出的结果是 0 解决办法： 在 n 传入时加 ref, ref()方法指明 n 是一个引用 */ function&lt;int(int, int)&gt; f5 = bind(add_cnt, add, ref(n), placeholders::_1, placeholders::_2); f5(89, 54); f5(55, 25); f5(77, 14); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; thread类用法和 bind 用法差不多, 比 c中的 thread方便多了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;thread&gt;using namespace std;void func() &#123; cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;&#125;void func2(int x) &#123; cout &lt;&lt; x &lt;&lt; &quot; hello world&quot; &lt;&lt; endl; return ;&#125;void func3(int &amp;x) &#123; x += 1; cout &lt;&lt; x &lt;&lt; &quot; hello world&quot; &lt;&lt; endl;&#125;int main() &#123; thread t1(func); thread t2(func); thread t3(func); t1.join(); t2.join(); t3.join(); thread t4(func2, 4); thread t5(func2, 5); thread t6(func2, 6); t4.join(); t5.join(); t6.join(); int n = 0; thread t7(func3, ref(n)); thread t8(func3, ref(n)); thread t9(func3, ref(n)); t7.join(); t8.join(); t9.join(); cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 图灵完备性模板可以在编译阶段就把结果给计算出来这样就节约了大量的运行时间 下面代码在编译阶段就把结果计算了出来，让编译器运行帮我们计算 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cmath&gt;using namespace std;//判断奇偶template&lt;int n&gt;struct IsEven &#123; static constexpr int r = !(n % 2);&#125;;//求a+btemplate&lt;int a, int b&gt;struct Add &#123; static constexpr int r = a + b;&#125;;//模板实现递归(循环), 求 1-n的和template&lt;int n&gt;struct Sum &#123; static constexpr int r = n + Sum&lt;n - 1&gt;::r;&#125;;template&lt;&gt;struct Sum&lt;0&gt; &#123; static constexpr int r = 0;&#125;;//求阶乘template&lt;int n&gt;struct Factorial &#123; static constexpr int r = n * Factorial&lt;n - 1&gt;::r;&#125;;template&lt;&gt;struct Factorial&lt;1&gt; &#123; static constexpr int r = 1;&#125;;/*****************************判断素数1******************/template&lt;int n, int i&gt;struct getNextN &#123; static constexpr int r = (i * i &gt; n ? 0 : n);&#125;;template&lt;int n, int i&gt;struct getNextI &#123; static constexpr int r = (n % i == 0 ? 0 : i + 1);&#125;;template&lt;int n, int i&gt;struct IsTest &#123; static constexpr int r = IsTest&lt;getNextN&lt;n, i&gt;::r, getNextI&lt;n, i&gt;::r&gt;::r;&#125;;template&lt;int i&gt;struct IsTest&lt;0, i&gt; &#123; static constexpr int r = 1;&#125;;template&lt;int i&gt;struct IsTest&lt;2, i&gt; &#123; static constexpr int r = 1;&#125;;template&lt;int n&gt;struct IsTest&lt;n, 0&gt; &#123; static constexpr int r = 0;&#125;;//入口template&lt;int n&gt;struct IsPrime &#123; static constexpr int r = IsTest&lt;n, 2&gt;::r;&#125;;/*******************************************************//*********************判断素数2*****************template&lt;int n, int m&gt;struct Check&#123; static constexpr bool r = (n % m != 0) &amp;&amp; Check&lt;n, m-1&gt;::r;&#125;;template&lt;int n&gt;struct Check&lt;n, 2&gt;&#123; static constexpr bool r = (n % 2 != 0);&#125;;template&lt;int n&gt;struct IsPrime&#123; static constexpr int r = Check&lt;n, (int)sqrt(n)&gt;::r;&#125;;**********************************************//******求 n 内素数和****/template&lt;int n&gt;struct SumPrime &#123; static constexpr int r = (n * IsPrime&lt;n&gt;::r) + SumPrime&lt;n - 1&gt;::r;&#125;;template&lt;&gt;struct SumPrime&lt;1&gt; &#123; static constexpr int r = 0;&#125;;/************************/int main() &#123; cout &lt;&lt; IsEven&lt;123&gt;::r &lt;&lt; endl; cout &lt;&lt; IsEven&lt;124&gt;::r &lt;&lt; endl; cout &lt;&lt; Add&lt;5, 7&gt;::r &lt;&lt; endl; cout &lt;&lt; Sum&lt;10&gt;::r &lt;&lt; endl; cout &lt;&lt; Sum&lt;100&gt;::r &lt;&lt; endl; cout &lt;&lt; Factorial&lt;5&gt;::r &lt;&lt; endl; cout &lt;&lt; Factorial&lt;10&gt;::r &lt;&lt; endl; cout &lt;&lt; IsPrime&lt;9973&gt;::r &lt;&lt; endl; cout &lt;&lt; IsPrime&lt;87&gt;::r &lt;&lt; endl; cout &lt;&lt; IsPrime&lt;1537&gt;::r &lt;&lt;endl; cout &lt;&lt; IsPrime&lt;65&gt;::r &lt;&lt; endl; cout &lt;&lt; SumPrime&lt;10&gt;::r &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"最短路径算法","slug":"1.算法/最短路径算法","date":"2020-08-12T08:24:22.595Z","updated":"2020-08-13T14:03:59.163Z","comments":true,"path":"2020/08/12/1.算法/最短路径算法/","link":"","permalink":"http://yoursite.com/2020/08/12/1.%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"Floyd算法 解决多源最短路径 算法讲解： 首先，ans[x][x]:x到x的距离置为0， 两点不通的置为一个极大值 如果 x 到 y 中间不经过任何点，即 x 直接到 y, 则会有一个 距离 ans[x][y] 如果从 x到y中间经过点1, 则距离可表示为 ans[x][y] = ans[x][1] + ans[1][y], 我们在这个值和原来的ans[x][y]中取一个较小值 如果中间又可经过点2, 同理距离可表示为 ans[x][y] = ans[x][2] + ans[2][y], 我们在这个值和上一个的ans[x][y]中取一个较小值， 注意！上一个ans[x][y]是经过 1之后得到的较小值 因此，中间点可以从 1～n, 我们用一个for循环 从 x 到 y又是一个两层循环 例题 洛谷P4779 单源最短路径 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cstring&gt;using namespace std;int n, m, s, ans[1000][1000];int main() &#123; memset(ans, 0x3F, sizeof(ans)); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; for (int i = 0; i &lt; m; i++) &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; ans[a][b] = c; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans[i][i] = 0; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; ans[j][k] = min(ans[j][k], ans[j][i] + ans[i][k]); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (i != 1) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; ans[s][i]; &#125; cout &lt;&lt; endl; return 0;&#125; 当然这样做，不能通过！只是演示代码 Dijkstra算法迪杰斯特拉算法","categories":[{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"最短路径算法","slug":"最短路径算法","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"}]},{"title":"关键字和右值","slug":"c++/5.关键字和右值","date":"2020-08-12T02:56:36.145Z","updated":"2020-08-13T16:00:37.711Z","comments":true,"path":"2020/08/12/c++/5.关键字和右值/","link":"","permalink":"http://yoursite.com/2020/08/12/c++/5.%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%8F%B3%E5%80%BC/","excerpt":"","text":"关键字思考(c++11)autoauto 关键字在编译阶段自动进行类型推导 遍历容器时使用更方便 四种情况不能用: 不能用在函数参数 不能用在模板参数 不能定义数组 不能用于非静态成员变量 （其实我发现，只要变量不初始化就用不了） 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main() &#123; auto a = 123; cout &lt;&lt; sizeof(a) &lt;&lt; endl; map&lt;int, int&gt; arr; arr[44848798] = 798213; arr[12265] = 320; arr[65] = 33022; for (map&lt;int, int&gt;::iterator iter = arr.begin(); iter != arr.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; for (auto iter = arr.begin(); iter != arr.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; for (auto x : arr) &#123; //c++11新语法 cout &lt;&lt; x.first &lt;&lt; &quot; &quot; &lt;&lt; x.second &lt;&lt; endl; &#125; return 0;&#125; const作用在运行期 constexpr作用在编译期，在编译期就会确定表达式的具体值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;constexpr int f(int x) &#123; //c++11 constexpr不能修饰递归函数 return 3 * x * x + x;&#125;class A &#123; public: constexpr A(int x, int y) : x(x), y(y) &#123;&#125; int x, y;&#125;;int main() &#123; const int a = 123; cout &lt;&lt; a &lt;&lt; endl; int b; cin &gt;&gt; b; const int c = 2 * b; //const: 运行期状态, 这里发现编译的时候是不确定c的值的 int n; cin &gt;&gt; n; //constexpr int m = 2 * n; //constexpr 修饰:编译器常量 constexpr int m = 2 * 123; cout &lt;&lt; m &lt;&lt; endl; constexpr int x = f(12); constexpr A t(2, 3); //初始化一个编译器的常量对象, 把构造函数前加constexpr cout &lt;&lt; t.x &lt;&lt; &quot;, &quot; &lt;&lt; t.y &lt;&lt; endl; return 0;&#125; final 被final修饰的方法，子类不能进行重写 被final修饰的类，其他类不能进行继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A : public map&lt;int, int&gt; &#123; public: virtual void say() &#123; cout &lt;&lt; &quot;Claa A : hello world&quot; &lt;&lt; endl; &#125;&#125;;class B final : public A &#123; //加上final, 此类不能再被继承 public: void say() final override &#123; //加上final, 子类就不能在重写此方法 cout &lt;&lt; &quot;Class B : hell world&quot; &lt;&lt; endl; &#125;&#125;;/*class C : public B &#123; public: //void say() &#123; // cout &lt;, &quot;Class B : hell world&quot; &lt;&lt; endl; //&#125;&#125;;*/int main() &#123; A a; a[55] = 569; a[215] = 545; for (auto x : a) &#123; cout &lt;&lt; x.first &lt;&lt; &quot; &quot; &lt;&lt; x.second &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; nullptrNULL 实际上是整型0，被强转了 (void*)0 而 nullptr本身就是一个地址，空的地址 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int f(int x) &#123; cout &lt;&lt; &quot;output in valu: &quot; &lt;&lt; x &lt;&lt; endl; return 0;&#125;int f(int *x) &#123; cout &lt;&lt; &quot;output address: &quot; &lt;&lt; x &lt;&lt; endl; return 0;&#125;int main() &#123; printf(&quot;%lld\\n&quot;, (long long)nullptr); cout &lt;&lt; sizeof(NULL) &lt;&lt; endl; int n = 123, *p = &amp;n; f(n); f(p); f(nullptr); f((int)NULL); return 0;&#125; 左值和右值最大的作用就是区分流程 左值和右值 光哥：同一的变量，单一的方式，访问到同样的结果就是左值，否则为右值 说白了就是，可以为这个表达式或表量赋值，那么它就是左值，否则就是右值 像一个中间产生的一个临时变量肯定给他赋不了值，它就是右值， 比如 a = 12 + 13 + 16 12 + 13会生成一个临时变量，它是右值 比如a++ ,想给 (a++) 赋值明显不能，那它就是右值 但是如果给(++a)赋值是可以的， 那 ++a就是一个左值 如何判断一个表达式是左值还是右值? ​ 定义一个传左值引用的函数，一个传右值引用的函数，倆函数同名，调用时将表达时传入，观察实际调用的是哪个函数来确定左右值 左值引用和右值引用&amp;就是左值引用， &amp;&amp;就是右值引用 左值会优先绑定在左值引用上， 右值会优先绑定在右值引用上 注意点： 如果形参是左值引用，实参传的是一个右值，要想编译通过，就在形参前加 const 一个形参是右值的函数，该参数在该函数内部实际上是一个左值 1234void f(int &amp;&amp;x) &#123; x += 1; return;&#125; 这里的 x虽然是一个右值引用，但它在该函数内，进行运算赋值是可以的，因此是一个左值，如果在函数里再调用另外两个函数（同样一个是右值引用的，一个传左值引用的，它会优先调用左值引用的。 这并不是想要的结果 因此**forward&lt;&gt;**帮我们解决的这一问题， 它会把变量转换为&lt;&gt;内的类型 因此可以在f函数内添加一句 forward&lt;int &amp;&amp;&gt;(x) 而 move 函数是将变量强制转换成一个 右值 move(x) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;#define TEST(a, f) &#123; \\ cout &lt;&lt; #a &lt;&lt; &quot; : &quot; &lt;&lt; #f &lt;&lt; &quot; &quot;; \\ f(a); \\&#125;void f2(int &amp;x) &#123; cout &lt;&lt; &quot;left value&quot; &lt;&lt; endl;&#125;void f2(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;right value&quot; &lt;&lt; endl;&#125;void f(int &amp;x) &#123; cout &lt;&lt; &quot;left value&quot; &lt;&lt; endl; TEST(x, f2);&#125;void f(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;right value&quot; &lt;&lt; endl; //在f内部，这里x就是左值了，（可以放=左边） //TEST(x, f2); //这里就会按左值调用f2 TEST(forward&lt;int &amp;&amp;&gt;(x), f2); //向前传递 TEST(move(x), f2); //强制变成右值&#125;int test_func(const int &amp;&amp;x) &#123; //x += 1; cout &lt;&lt; x &lt;&lt; endl; return 0;&#125;int main() &#123; //表达式的返回结果可以放在等号左边则为左值 int a, b = 1, c = 3; (++a) = b + c; cout &lt;&lt; a &lt;&lt; endl; (a++); (a = b) = c; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; int arr[10]; arr[3] = 12; (a += 3) = 67; cout &lt;&lt; a &lt;&lt; endl; TEST(a += 3, f); TEST(1 + 4, f); TEST(b + c, f); TEST(a++, f); TEST(++a, f); test_func(123); test_func(move(a)); return 0;&#125; 移动构造函数在进行对象拷贝时， 我们之前都是调用的拷贝构造函数 如果对象成员中有连续存储空间（如一个数组），我们为了能进行真正的拷贝（即深拷贝），我们还需要显示的写出来拷贝构造函数，并在函数内实际地去申请相应的空间。 如果将一个临时的对象拷贝给另一个对象，我们则需要为新对象的成员开辟空间，并把临时对象的成员空间释放(析构时自动释放的)，这样很不划算，新开辟的空间和释放的空间存储的内容相同，这样我们就进行了一次看似多余的拷贝。其实有更好的办法，就是不为对象开辟新空间，而是直接把该对象的成员的指针指向这个临时对象的成员的那片存储区，再把临时对象成员指向nullptr ,这样就把临时对象中的占用的存储空间移到了新的对象这里。 谁来完成这一个操作呢，没错，就是移动构造函数，我们需要把移动构造函数写出来，他的形参是一个右值引用。 当进行对象拷贝时， 它就会被调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cstring&gt;using namespace std;namespace haizei &#123;class string &#123; public: string() &#123; cout &lt;&lt; &quot;default constructor&quot; &lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = 10; this-&gt;buff = new char[this-&gt;__buff_size]; this-&gt;__length = 0; &#125; string(const char *str) &#123; cout &lt;&lt; &quot;const char constructor: &quot;&lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = strlen(str) + 1; this-&gt;buff = new char[this-&gt;__buff_size]; strcpy(this-&gt;buff, str); this-&gt;__length = this-&gt;__buff_size - 1; &#125; string(const string &amp;s) &#123; //左值拷贝 cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = s.__buff_size; this-&gt;__length = s.__length; this-&gt;buff = new char[this-&gt;__buff_size]; strcpy(this-&gt;buff, s.buff); &#125; string(string &amp;&amp;s) &#123; //移动构造函数 //右值拷贝，将临时对象的存储区直接转交给当前对象，当前对象就不用再开辟空间复制内容了 cout &lt;&lt; &quot;move constructor: &quot; &lt;&lt; this &lt;&lt; &quot;, &quot; &lt;&lt; &amp;s &lt;&lt; endl; this-&gt;__buff_size = s.__buff_size; this-&gt;__length = s.__length; this-&gt;buff = s.buff; s.buff = nullptr; &#125; const char *c_str() const &#123; return buff; &#125; char &amp;operator[](int ind) &#123; return this-&gt;buff[ind]; &#125; string operator+(const string &amp;s) &#123; cout &lt;&lt; &quot;operator + &quot; &lt;&lt; this &lt;&lt; endl; int size = __length + s.__length + 1; char *temp = new char[size]; strcpy(temp, this-&gt;buff); strcat(temp, s.buff); return temp; //这里会调用有参构造函数 &#125; int size() &#123; return this-&gt;__length; &#125; char &amp;at(int ind) &#123; //at是需要判断边界的 if (ind &lt; 0 || ind &gt;= __length) &#123; cout &lt;&lt; &quot;String Error : out of range&quot; &lt;&lt; endl; return __end; &#125; return this-&gt;operator[](ind); &#125; ~string() &#123; cout &lt;&lt; &quot;destructor &quot; &lt;&lt; this &lt;&lt; endl; if (this-&gt;buff) delete this-&gt;buff; &#125; private: int __length, __buff_size; char *buff; char __end;&#125;;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, const haizei::string &amp;s) &#123; out &lt;&lt; s.c_str(); return out;&#125;int main() &#123; haizei::string s1 = &quot;hello world&quot;, s2 = &quot;, haizei&quot;, s3 = &quot;, harbin.&quot;; cout &lt;&lt; &quot;======s4 begin=====&quot; &lt;&lt; endl; haizei::string s4 = s1 + s2 + s3; cout &lt;&lt; &quot;======s4 end=======&quot; &lt;&lt; endl; haizei::string s5 = s4; cout &lt;&lt; s4 &lt;&lt; endl; cout &lt;&lt; s5 &lt;&lt; endl; s4[3] = &#x27;=&#x27;; cout &lt;&lt; s4 &lt;&lt; endl; cout &lt;&lt; s5 &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; endl; s1[3] = &#x27;6&#x27;; cout &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; s1 + s2 + s3 &lt;&lt; endl; for (int i = 0; i &lt; s1.size(); i++) &#123; cout &lt;&lt; s1[i] &lt;&lt; endl; &#125; return 0;&#125; g++ -fno-elide-constructors 选项可以使程序不进行返回值优化","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"多态","slug":"c++/4.多态","date":"2020-08-09T11:45:35.612Z","updated":"2020-08-17T08:44:13.451Z","comments":true,"path":"2020/08/09/c++/4.多态/","link":"","permalink":"http://yoursite.com/2020/08/09/c++/4.%E5%A4%9A%E6%80%81/","excerpt":"虚函数","text":"虚函数 普通成员方法跟着类走， 虚函数跟着对象走 用父指针new出一个子对象，在没有虚函数的情况下，当父类指针调用同名方法时无法调用到子类的同名方法。 虽然new出来的是子类对象。 但调用普通方法时看的是前面的指针属于哪一个类就会调用哪一个类中的方法 而如果有虚函数，调用虚函数时，看的是new出来的对象具体是哪一个类，对象属于哪一个类，就调用哪一个类的方法。 这就是虚函数跟着对象走 虚函数声明 1virtual void func() &#123;&#125; 在方法前加virtual关键字 virtual 关键字不能修饰类方法(static) 纯虚函数 1virtual void func() = 0; 纯虚函数也叫接口方法 拥有纯虚函数的类叫抽象类(接口) 抽象类不能实例化 子类必须实现纯虚函数 补充 只要有继承，父类的析构函数就必须声明为 virtual 确保能正确析构子类的空间 原因：用父类的指针a去指向一个new出来子类对象。 如果父类析构函数没有声明为virtual, 那么析构函数就是普通成员方法（跟着类走），当delete a时， 它会执行父类中的析构函数，而不会执行子类中析构函数，那也就并没有析构掉子类的空间。 如果将父类析构函数声明为 virtual, 那么析构函数就会跟着对象走，new出来什么对象，就会执行哪个对象的析构函数 这样就会正确析构子类和父类 它可以方便进行类型转换 dynamic_cast override必须写 当子类重写父类方法时，务必要在方法名后面加上override，它能将运行期的错误变成编译期的错误 如果不写，一旦重写父类方法时把方法名字写错，那在编译期是看不到的 虚函数表在一个对象的存储空间中，最上面是一个8字节的虚函数表指针，他指向虚函数表，虚函数表存储所有虚函数的地址 一个类有一张虚函数表，他的所有对象的虚函数表指针都指向同一张虚函数表。 this指针说明: 实际上在成员方法中，第一个参数是 this指针，他是隐藏起来的 虚函数表的发现与验证当父类中没有虚函数时，输出子类对象的大小，发现和我们预期一致 当在父类中添加一个虚函数或多个虚函数时，发现子类对象的大小都会只增多8字节，猜测多了个函数指针，这就是虚函数表的地址 在外部定义一个函数指针，通过一个对象来找到虚函数表，并调用虚函数表中的方法，发现与猜测结果相同 this指针通过函数指针调用虚函数时，我们传一个参数，发现并不能正常调用虚函数了，这是因为虚函数第一个参数是一个隐藏的this指针，我们就显式的多传一个参数 第一个给他传一个对象的地址，发现调用的正是该对象的虚函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Animal &#123;public: virtual void run() &#123; cout &lt;&lt; &quot;I don&#x27;t know how to run&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can run with four legs&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can run with four legs, tail yao a yao!&quot; &lt;&lt; endl; &#125;&#125;;class Bat : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can fly!&quot; &lt;&lt; endl; &#125;&#125;;class A &#123;public : A() = default; A(string s) &#123; cout &lt;&lt; &quot;param constructor&quot; &lt;&lt; endl; &#125; A(const A &amp;a) &#123; cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; &#125; int x; virtual void say(int xx) &#123; cout &lt;&lt; this &lt;&lt; endl; cout &lt;&lt; &quot;Class A : I can say, xx = &quot; &lt;&lt; xx &lt;&lt; &quot;, this-&gt;x = &quot;&lt;&lt; x &lt;&lt; endl; &#125;&#125;;typedef void (*func)(void *, int); //函数指针A retA() &#123; A temp_a(&quot;hello world&quot;); return temp_a;&#125;class Base &#123; public: Base() &#123; cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; endl; this-&gt;x = new int; &#125; virtual ~Base() &#123; cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl; delete this-&gt;x; &#125; private: int *x;&#125;;class Base_A: public Base &#123; public: Base_A() &#123; cout &lt;&lt; &quot;Base_A constructor&quot; &lt;&lt; endl; this-&gt;y = new int; &#125; ~Base_A() &#123; cout &lt;&lt; &quot;Base_A destructor&quot; &lt;&lt; endl; &#125; private: int *y;&#125;;int main() &#123; Base *ba = new Base_A(); delete ba; //普通的成员方法跟着类走，执行此句就不会调用Base_A的~Base_A(); //因此父类的析构函数一定得是虚函数 cout &lt;&lt; sizeof(A) &lt;&lt; endl; A temp_a, temp_b; temp_a.x = 9973; temp_b.x = 10000; temp_a.say(67); A temp_c = retA(); ((func **)(&amp;temp_a))[0][0](&amp;temp_b, 6); //用函数指针来调用虚函数表中的方法, 并且给虚函数say传参数 //虽然say中只有一个参数，但实际上，他还有一个隐藏的this, 第一个参数实际就是this, 隐藏了 //我们在这里通过函数指针来调用这个方法时，第一个方法就要传进去一个实际的对象地址 //他才会正确调用该对象的say方法 //这里虽然是通过temp_a对象找到的虚函数表中的say,但他并不会调用temp_a的say方法，他具体看的是第一个参数this指针是指向谁， //我们传进去temp_b的地址，他自然也就会调用temp_b的say方法, 并且把 6 作为复制给第二的参数 xx //我们在say中输出 this, 发现他确实也不是 temp_a 的地址 srand(time(0)); Cat a; Animal &amp;b = a; Animal *c[10]; cout &lt;&lt; sizeof(Cat) &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; int op = rand() % 3; switch (op) &#123; case 0: c[i] = new Cat(); break; case 1: c[i] = new Dog(); break; case 2: c[i] = new Bat(); break; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; c[i]-&gt;run(); &#125; return 0;&#125; 运行结果： dynamic_cast这个类来做父类和子类的类型转换，当转换失败时就会返回NULL 父类对象地址能否转换成一个子类对象指针，对比的就是他们的虚函数表指针是否相同 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A &#123; public: virtual ~A() &#123;&#125; private: &#125;;class B : public A &#123; public: void sayB() &#123; cout &lt;&lt; &quot;this is class B, x = &quot; &lt;&lt; x &lt;&lt; endl; &#125; int x;&#125;;class C : public A &#123; public: void sayC() &#123; cout &lt;&lt; &quot;this is class C, x =&quot; &lt;&lt; x &lt;&lt; endl; &#125; double x;&#125;;class D : public A &#123; public: void sayD() &#123; cout &lt;&lt; &quot;this is class D, x =&quot; &lt;&lt; x &lt;&lt; endl; &#125; string x;&#125;;int my_dynamic_cast(A *ta) &#123; char **pa = (char **)(ta); char **pb = (char **)(new B()); char **pc = (char **)(new C()); char **pd = (char **)(new D()); int ret = -1; if (pa[0] == pb[0]) ret = 0; else if (pa[0] == pc[0]) ret = 1; else if (pa[0] == pd[0]) ret = 2; return ret;&#125;int main() &#123; srand(time(0)); A *pa; B *pb; C *pc; D *pd; switch (rand() % 3) &#123; case 0: pb = new B(); pa = pb; pb-&gt;x = 254; break; case 1: pc = new C(); pa = pc; pc-&gt;x = 565.5; break; case 2: pd = new D(); pa = pd; pd-&gt;x = &quot;hell world&quot;; break; &#125; if ((pb = dynamic_cast&lt;B *&gt;(pa))) &#123; //转换失败返回NULL; cout &lt;&lt; &quot;class B :&quot;; pb-&gt;sayB(); &#125; else if ((pc = dynamic_cast&lt;C *&gt;(pa))) &#123; cout &lt;&lt; &quot;class C :&quot;; pc-&gt;sayC(); &#125; else if ((pd = dynamic_cast&lt;D *&gt;(pa))) &#123; cout &lt;&lt; &quot;class D :&quot;; pd-&gt;sayD(); &#125; switch (my_dynamic_cast(pa)) &#123; case 0: ((B *)(pa))-&gt;sayB(); break; case 1: ((C *)(pa))-&gt;sayC(); break; case 2: ((D *)(pa))-&gt;sayD(); break; &#125; return 0;&#125; 多态练习实现一个自定义哈希函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;namespace haizei &#123;class IHashFunc &#123; public: virtual int operator()(int) = 0;&#125;;class HashTable &#123; typedef int (*HashFunt_T)(int); typedef pair&lt;int, int&gt; PII; public: HashTable(HashFunt_T); HashTable(IHashFunc &amp;); int &amp;operator[](int); private: HashTable(HashFunt_T, IHashFunc *, int); int hash_type; HashFunt_T func1; IHashFunc *func2; int __size; PII **data;&#125;;HashTable::HashTable(HashFunt_T func1, IHashFunc *func2, int hash_type): func1(func1), func2(func2), hash_type(hash_type) &#123; this-&gt;__size = 1000; this-&gt;data = new PII*[this-&gt;__size]; for (int i = 0; i &lt; this-&gt;__size; i++) this-&gt;data[i] = nullptr;&#125;HashTable::HashTable(HashFunt_T func) : HashTable(func, nullptr, 1) &#123;&#125;HashTable::HashTable(IHashFunc &amp;func): HashTable(nullptr, &amp;func, 2) &#123;&#125;int &amp;HashTable::operator[](int x) &#123; int hash = 0; switch (hash_type) &#123; case 1: hash = func1(x); break; case 2: hash = (*func2)(x); break; &#125; if (hash &lt; 0) hash &amp;= 0x7fffffff; int ind = hash % __size, t = 1; while (data[ind] &amp;&amp; data[ind]-&gt;first != x) &#123; ind += t * t; if (ind &lt; 0) ind = ind &amp; 0x7fffffff; ind %= __size; t += 1; &#125; if (data[ind] == nullptr) data[ind] = new PII(x, 0); return data[ind]-&gt;second; &#125;&#125; //end of namespace haizeiint hash1(int x) &#123; return (x &lt;&lt; 1) ^ (x &lt;&lt; 3) ^ (x &gt;&gt; 5);&#125;class MyHashFunc : public haizei::IHashFunc &#123; public: int operator()(int x) override &#123; return (x &lt;&lt; 1) ^ (x &lt;&lt; 3) ^ (x &gt;&gt; 5); &#125;&#125;;int main() &#123; MyHashFunc hash2; haizei::HashTable h1(hash1); haizei::HashTable h2(hash2); h1[123] = 354; h2[123] = 345; cout &lt;&lt; h1[123] &lt;&lt; endl; cout &lt;&lt; h2[123] &lt;&lt; endl; cout &lt;&lt; h1[789] &lt;&lt; endl; cout &lt;&lt; h2[10000] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"运算符重载","slug":"c++/3.运算符重载","date":"2020-08-09T11:33:40.484Z","updated":"2020-08-14T10:55:58.166Z","comments":true,"path":"2020/08/09/c++/3.运算符重载/","link":"","permalink":"http://yoursite.com/2020/08/09/c++/3.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"","text":"简易cout、cin的实现类内重载 12345678910111213141516171819202122232425262728293031323334353637//自己写一个命名空间namespace myspace &#123;class istream &#123;public: //返回对象的引用:为了一直使用这个cin对象，避免再拷贝一份 istream &amp;operator&gt;&gt;(int &amp;n) &#123; //参数传引用，避免再拷贝一份n std::cin &gt;&gt; n; //可以用scanf来实现 return *this; &#125;private:&#125;;class ostream &#123;public: ostream &amp;operator&lt;&lt;(int &amp;n) &#123; std::cout &lt;&lt; n; //可用printf(&quot;%g&quot;)来实现 return *this; &#125; ostream &amp;operator&lt;&lt;(const char *msg) &#123; std::cout &lt;&lt; msg; return *this; &#125;private:&#125;;istream cin;ostream cout;&#125;;int main() &#123; int n, m; myspace::cin &gt;&gt; n &gt;&gt; m; //系统默认为执行 cin.operator&gt;&gt;(n) myspace::cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot;\\n&quot;; return 0;&#125; 类外重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//自己写一个命名空间namespace myspace &#123;class istream &#123;public: //返回对象的引用:为了一直使用这个cin对象，避免再拷贝一份 istream &amp;operator&gt;&gt;(int &amp;n) &#123; //参数传引用，避免再拷贝一份n std::cin &gt;&gt; n; return *this; &#125;private:&#125;;class ostream &#123;public: ostream &amp;operator&lt;&lt;(int &amp;n) &#123; std::cout &lt;&lt; n; return *this; &#125; ostream &amp;operator&lt;&lt;(const char *msg) &#123; std::cout &lt;&lt; msg; return *this; &#125;private:&#125;;istream cin;ostream cout;&#125;;//类外重载运算符myspace::ostream &amp;operator&lt;&lt;(myspace::ostream &amp;out, double &amp;z) &#123; std::cout &lt;&lt; z; return out;&#125;ostream &amp;operator+(ostream &amp;out, const int &amp;a) &#123; //这时的a不仅可以是传过来的常量(子面量)也可以是变量 cout &lt;&lt; a; return out;&#125;int main() &#123; int n, m; //cin &gt;&gt; n: 系统会将其转化为 cin.oprator&gt;&gt;(n) myspace::cin &gt;&gt; n &gt;&gt; m; myspace::cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot;\\n&quot;; double k = 5.5; myspace::cout &lt;&lt; k &lt;&lt; &quot;\\n&quot;; (((((cout + 8) &lt;&lt; &quot; &quot;) + 9 )&lt;&lt; &quot; &quot;) + 10) &lt;&lt; &quot;\\n&quot;; //要注意 + 和 &lt;&lt; 的优先级 return 0;&#125; 重载实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//重载运算符的方法的参数个数一定要和原来运算符的目数相同//优先匹配类内重载#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class Point &#123;public : Point() : __x(0), __y(0) &#123;&#125; Point(int x, int y) : __x(x), __y(y) &#123;&#125; int x() const &#123; return __x; &#125; int y() const &#123; return __y; &#125; Point operator+(const Point &amp;a) &#123; return Point(x() + a.x(), y() + a.y()); &#125; Point &amp;operator+=(const Point &amp;a) &#123; __x += a.x(); __y += a.y(); return *this; &#125; Point &amp;operator++() &#123; //前++ __x += 1; __y += 1; return *this; &#125; Point operator++(int) &#123; //后++ //返回不能是引用，因为方法一结束，temp就没了，所以要返回一个temp的拷贝 Point temp(*this); __x += 1; __y += 1; return temp; &#125;private: int __x, __y;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const Point &amp;a) &#123; out &lt;&lt; &quot;Point (&quot; &lt;&lt; a.x() &lt;&lt; &quot;, &quot; &lt;&lt; a.y() &lt;&lt; &quot;)&quot;; return out;&#125;int main() &#123; Point a(4, 5), b(3, 4), c(1, 1); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; &quot;pre incr: &quot; &lt;&lt; ++(c += b) &lt;&lt; endl; //++(c += b); cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;after incr: &quot; &lt;&lt; c++ &lt;&lt; endl; int n = 6, m = 7; (n += m)++; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 特殊运算符的重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class A &#123;public : A() &#123; arr = new int[10]; &#125; A(const A &amp;a) : A() &#123; //深拷贝，系统默认拷贝构造是浅拷贝() for (int i = 0; i &lt; 10; i++) &#123; this-&gt;arr[i] = a.arr[i]; &#125; this-&gt;x = a.x; this-&gt;y = a.y; &#125; int x, y; int *arr;&#125;;class B &#123;public: B() : obj(nullptr)&#123; arr = new int[10]; arr[3] = 9972; &#125; B(A *obj) : B() &#123; this-&gt;obj = obj; &#125; int operator()(int a, int b)&#123; return a + b; &#125; int &amp;operator[](int ind) &#123; //返回引用,返回的是ind处的变量 return arr[ind]; &#125; void operator[](const char *msg) &#123; cout &lt;&lt; msg &lt;&lt; endl; return ; &#125; A *operator-&gt;() &#123; return obj; &#125; A &amp;operator*() &#123; return *obj; &#125; ~B() &#123; delete arr; &#125;private: int *arr; A *obj;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const A &amp;a) &#123; out &lt;&lt; &quot;A(&quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;; return out;&#125;//主函数中是外部表现，类中是内部实现int main() &#123; B add; cout &lt;&lt; add(3, 5) &lt;&lt; endl; //函数对象(像函数的对象)，重载() add[3] = 787; //数组对象, 重载[] cout &lt;&lt; add[3] &lt;&lt; endl; add[&quot;hello world&quot;]; A a, b(a); //浅拷贝 a.x = 87, a.y = 852; B p = &amp;a; //指针对象 cout &lt;&lt; p-&gt;x &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;y &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; a.arr[3] = 111; b.arr[3] = 222; cout &lt;&lt; a.arr[3] &lt;&lt; endl; cout &lt;&lt; b.arr[3] &lt;&lt; endl; cout &lt;&lt; sizeof(a) &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class IntArray &#123; public: IntArray(int n) : n(n) &#123; this-&gt;arr = new int[n]; &#125; IntArray(IntArray &amp;obj) : n(obj.n)&#123; this-&gt;arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; this-&gt;arr[i] = obj[i]; &#125; &#125; int &amp;operator[](int ind) &#123; if (ind &gt;= 0) &#123; return this-&gt;arr[ind]; &#125; else &#123; return this-&gt;arr[this-&gt;n + ind]; &#125; &#125; void operator+=(int num) &#123; for (int i = 0; i &lt; n; i++) &#123; this-&gt;arr[i] += num; &#125; return ; &#125; IntArray operator++(int x) &#123; //后++, 无论后++还是前++都是要加的。所以要提前拷贝一份返回加之前的样子. IntArray temp(*this); for (int i = 0; i &lt; this-&gt;n; i++) &#123; this-&gt;arr[i] += 1; &#125; return temp; &#125; IntArray &amp;operator++() &#123; for (int i = 0; i &lt; this-&gt;n; i++) &#123; this-&gt;arr[i] += 1; &#125; return *this; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;, const IntArray &amp;); ~IntArray() &#123; delete[] this-&gt;arr; &#125; private: int *arr, n;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const IntArray &amp;a) &#123; out &lt;&lt; &quot;[ &quot;; for (int i = 0; i &lt; a.n; i++) &#123; out &lt;&lt; a.arr[i] &lt;&lt; &quot; &quot;; &#125; out &lt;&lt; &quot;]&quot;; return out;&#125;int main() &#123; srand(time(0)); IntArray a(10); for (int i = 0; i &lt; 10; i++) &#123; a[i] = rand() % 100; //！！这里要注意一下如何重载[], a[i]返回值应该是arr[i]这个变量的引用 &#125; cout &lt;&lt; a &lt;&lt; endl; //输出数组中所有的元素 cout &lt;&lt; a[4] &lt;&lt; endl; cout &lt;&lt; a[-2] &lt;&lt; endl; //输出倒数第2位的值 a += 5; //给数组的所有元素都加5 cout &lt;&lt; a &lt;&lt; endl; //输出数组中所有的元素 cout &lt;&lt; (a++) &lt;&lt; endl; //给数组中所有元素都加1 cout &lt;&lt; (++a) &lt;&lt; endl; //给数组中所有元素都加1 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"继承","slug":"c++/2.继承","date":"2020-08-09T11:26:43.790Z","updated":"2020-08-12T07:23:21.811Z","comments":true,"path":"2020/08/09/c++/2.继承/","link":"","permalink":"http://yoursite.com/2020/08/09/c++/2.%E7%BB%A7%E6%89%BF/","excerpt":"继承","text":"继承 继承,父类中的所有属性都会包含进子类中子类在内存中的存储，前半部分是存储父类的信息，后半部分是存储的本身的属性。所以子类对象的地址可以看成一个父类对象的地址 继承-子类的访问权限 子类无论是public继承、protected继承 还是private继承，他都无法访问到父类中private中的东西。但是父类中的public、protected都可以访问 继承-对外的访问权限 ==继承权限影响的是外部对子类中的 继承自父类的 属性和方法的访问权限== ==这些权限只能缩小不能放大== 1234567891011121314151617181920212223242526272829303132333435363738......class Animal &#123; public: Animal(string name, int age) : __name(name), age(age) &#123;&#125; void say() &#123; cout &lt;&lt; &quot;my name is: &quot; &lt;&lt; __name &lt;&lt; &quot;my age is: &quot; &lt;&lt; age &lt;&lt; endl; &#125; protected: string __name; private: int age;&#125;;class Cat : public Animal &#123; public : Cat() = delete; Cat(string name, int age) : Animal(name, age) &#123;&#125;&#125;;class Bat : protected Animal &#123; public: Bat() = delete; Bat(string name, int age) : Animal(name, age) &#123;&#125; void say() &#123; //this-&gt;Animal::say(); Animal::say(); cout &lt;&lt; &quot;Bat name: &quot; &lt;&lt; __name &lt;&lt; endl; //cout &lt;&lt; &quot;Bat age: &quot; &lt;&lt; age &lt;&lt; endl; //访问不了 &#125;&#125;;int main() &#123; Cat a(&quot;kitty&quot;, 29); a.say(); Bat b(&quot;hug&quot;, 16384); b.say(); return 0;&#125; 菱形继承c++支持多继承，但容易出现菱形继承，尽量避免这种情况出现 继承中的构造函数如何工作子类的构造函数 ： Cat() : 初始化列表 &#123;构造逻辑&#125; 在初始化列表结束后，初始化其实就已经完成了初始化列表可以显式的调用父类的构造函数，也可以隐式的不写(自动调用父类的默认构造函数) 子类实例化一个对象： 1. 会先调用子类构造函数 Cat() 2. 执行初始化参数列表（这里会先调用父类的构造函数，其次初始化子类中的属性） 3. 父类构造结束，然后子类的构造在结束 4. 再执行子类构造函数中的{构造逻辑} ==因此说：父类先完成构造，子类后完成构造==注意！！：在初始化列表中初始化子类的属性时、书写属性的顺序与初始化的顺序无关而与属性在子类中的声明顺序有关 12345678910111213141516171819202122232425262728293031323334353637383940class D &#123; public: D() &#123; cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl; &#125; ~D() &#123; cout &lt;&lt; &quot;D destructor&quot; &lt;&lt; endl; &#125;&#125;;class A &#123; public: A() = delete; A(int x, int y) &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; endl; &#125;&#125;;class B &#123; public: B() &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; endl; &#125;&#125;;class C : public D &#123; public: C() : a(3, 4), b() &#123; cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; endl; &#125; //显示的写出来初始化列表 ~C() &#123; cout &lt;&lt; &quot;C destructor&quot; &lt;&lt; endl; &#125; private: B b; A a;&#125;;int main() &#123; C c; return 0;&#125; 继承中的拷贝构造函数在子类构造函数中如果要调用父类的拷贝构造函数，就需要在初始化列表中显式的写出来，否则会默认调用父类的默认构造函数子类在内存中的存储，前半部分是存储父类的信息，后半部分是存储的本身的属性。所以子类对象的地址可以看成一个父类对象的地址，子类的地址就可以赋给父类指针。 12345678910111213141516171819202122232425262728293031323334class A &#123; public: A() &#123; cout &lt;&lt; &quot;class A constructor&quot; &lt;&lt; endl; this-&gt;x = 0x01020304; &#125; A(const A &amp;a) &#123; cout &lt;&lt; &quot;class A copy constructor&quot; &lt;&lt; this &lt;&lt; endl; &#125; int x;&#125;;class B : public A &#123; public: B() &#123; this-&gt;y = 0x05060708; cout &lt;&lt; &quot;class B constructor&quot; &lt;&lt; endl; &#125; B(const B &amp;b) : A(b) &#123; //要显示的调用父类的构造，否则默认是调用默认构造 cout &lt;&lt; &quot;class B copy constructor&quot; &lt;&lt; this &lt;&lt; endl; &#125; int y;&#125;;int main() &#123; B b1; B b2(b1); const char *msg = (const char *)(&amp;b1); for (int i = 0; i &lt; sizeof(B); i++) &#123; printf(&quot;%X&quot;, msg[i]); &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"类与对象","slug":"c++/1.类与对象","date":"2020-08-09T11:18:28.994Z","updated":"2020-08-14T01:14:39.663Z","comments":true,"path":"2020/08/09/c++/1.类与对象/","link":"","permalink":"http://yoursite.com/2020/08/09/c++/1.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"","text":"成员属性与方法 每个对象都有自己的一份属性和方法 访问权限public ：公共访问属性。protected ： 私有访问属性。孩子们和自己可以访问属性，其他的不可以private：受保护的访问权限。friend ：是类外的一个函数，类中将一函数声明为friend，该函数就可以访问类中的成员 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class People &#123; friend int main(); //友元函数 int x, y;public: void set(int x); void say();&#125;;struct People2 &#123; int x, y;&#125;;void People::set(int x) &#123; cout &lt;&lt; &quot;set function: &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = x; return ;&#125; void People::say() &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; return ;&#125;int main() &#123; People a; People2 b; a.set(3); a.y = 18432; a.say(); cout &lt;&lt; &quot;a object: &quot; &lt;&lt; &amp;a &lt;&lt; endl; b.x = 4; cout &lt;&lt; b.x &lt;&lt; endl; return 0;&#125; 运行结果 特殊函数 默认构造函数系统默认存在没有参数的什么也不做的构造函数系统自动调用 有参构造函数自己写一个有参的构造函数，默认的就没了 转换构造函数有参构造函数但只有一个参数 拷贝构造函数同类型的对象复制默认拷贝：逐个将对象的每个成员变量拷贝给另一个对象（如果源对象中有个指针，默认拷贝的话，那就会把指针的值拷贝一份，那样这两对象中的指针就会指向同一个空间，就不会实现真正的拷贝，看代码） 123456789101112131415161718192021222324252627class A &#123; public: A() &#123; this-&gt;arr = new int[100]; &#125; int *arr; int x, y;&#125;;int main() &#123; A a1; a1.x = 3, a1.y = 4; A a2 = a1; cout &lt;&lt; &quot;a1.x:&quot; &lt;&lt; a1.x &lt;&lt; &quot; a1.y:&quot; &lt;&lt; a1.y &lt;&lt; endl; cout &lt;&lt; &quot;a2.x:&quot; &lt;&lt; a2.x &lt;&lt; &quot; a2.y:&quot; &lt;&lt; a2.y &lt;&lt; endl; cout &lt;&lt; endl; a1.x = 555; a2.x = 666; cout &lt;&lt; &quot;a1.x:&quot; &lt;&lt; a1.x &lt;&lt; &quot; a1.y:&quot; &lt;&lt; a1.y &lt;&lt; endl; cout &lt;&lt; &quot;a2.x:&quot; &lt;&lt; a2.x &lt;&lt; &quot; a2.y:&quot; &lt;&lt; a2.y &lt;&lt; endl; a1.arr[0] = 89; a2.arr[0] = 79988; cout &lt;&lt; &quot;a1.arr[0]:&quot; &lt;&lt; a1.arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;a2.arr[0]:&quot; &lt;&lt; a2.arr[0] &lt;&lt; endl; return 0;&#125; 浅拷贝 系统的默认的拷贝,上面代码 深拷贝 为了解决默认拷贝构造的bug,就需要自己写一个拷贝构造函数,(在自己写的拷贝构造函数中重新开辟自己指针所指向的空间。）1234A(const A &amp;obj) : x(obj.x), y(obj.y) &#123; this-&gt;arr = new int[100]; memcpy(this-&gt;arr, obj.arr, sizeof(int) * 100);&#125; 复制赋值运算符析构函数函数结束系统自动调用，析构函数的调用顺序与构造函数的调用顺序正好相反因为后构造的可能会依赖到先构造的，如果先把先构造的给析构掉就可能出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;class People &#123;public : People() &#123; cout &lt;&lt; &quot;默认构造函数&quot; &lt;&lt; endl; &#125; //People() = default; //默认构造函数 People(string name) &#123; //有参构造函数（因为形参只有一个，也叫转换构造函数） cout &lt;&lt; &quot;param constructor&quot; &lt;&lt; endl; this-&gt;name = name; &#125; People(int x) &#123; //同上 cout &lt;&lt; &quot;int param constructor&quot; &lt;&lt; endl; this-&gt;x = x; &#125; People(const People &amp;a) &#123; //拷贝构造函数，这里的参数必须是引用 //否则，形参也会调用拷贝构造函数，会发生无限循环的调用 cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; this-&gt;name = a.name; this-&gt;x = a.x; &#125; void operator=(const People &amp;a) &#123; //赋值运算符 cout &lt;&lt; &quot;operator =&quot; &lt;&lt; endl; this-&gt;name = a.name; this-&gt;x = a.x; return ; &#125; ~People() &#123; //析构函数 cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; string name; int x;&#125;;void incr(int &amp;a) &#123; //引用小示例 a += 1; return ;&#125;int add(People a, People b) &#123; return a.x + b.x;&#125;int main() &#123; People f; //调用默认构造函数 int n = 7; incr(n); cout &lt;&lt; n &lt;&lt; endl; //4, 5会自动调用转换构造函数，先转换成People对象. add函数结束并调用两次析构函数 cout &lt;&lt; add(4, 5) &lt;&lt; endl; People a(&quot;hug&quot;); //调用(一个参数的)有参构造函数(转换构造函数) People b = string(&quot;hug&quot;); //同上 People c(543); //同上 People d = 678; //同上 cout &lt;&lt; a.name &lt;&lt; endl; cout &lt;&lt; b.name &lt;&lt; endl; cout &lt;&lt; c.x &lt;&lt; endl; cout &lt;&lt; d.x &lt;&lt; endl; //c = 987重点理解：987会先调用转换构造函数生成一个对象赋值给C, //赋值给C时注意！！这时候调用的不是转换构造函数也不是拷贝构造函数 //因为此时的C已不再是初次定义，因此它这次调用的是 赋值运算符函数！ //赋值给C之后，987生成的匿名对象会再调用析构函数。 c = 987; cout &lt;&lt; c.x &lt;&lt; endl; d = string(&quot;xiaoming&quot;); //调用有参构造函数(转换构造函数) cout &lt;&lt; d.name &lt;&lt; endl; People e = a; //调用拷贝构造函数 cout &lt;&lt; e.name &lt;&lt; endl; cout &lt;&lt; e.x &lt;&lt; endl; c = a; //c不是首次定义，此时调用赋值运算符函数 cout &lt;&lt; c.name &lt;&lt; endl; cout &lt;&lt; c.x &lt;&lt; endl; return 0;&#125; 运行结果 类属性与方法static 修饰所有对象共享一份 const方法不去修改任何成员属性的值const 限定符，它把一个对象转换成一个常量。 对象与引用 c++中的结构体与类C++中的struct实际是个类，里面的属性方法默认是public类中写个属性或方法默认是private 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;class Point &#123;public : Point() &#123; cout &lt;&lt; &quot;constructor : &quot; &lt;&lt; this &lt;&lt; endl; Point::total_cnt += 1; seek_cnt = 0; &#125; Point(const Point &amp;a) : Point() &#123; //拷贝构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;copy constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = a.x; this-&gt;y = a.y; &#125; Point(double z) : Point() &#123; //转换构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;convert constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = 99, this-&gt;y = 99; &#125; Point(int x, int y) : Point() &#123; //有参构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;param constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = x; this-&gt;y = y; &#125; void operator=(const Point &amp;a) &#123; //赋值运算符。会先调用默认构造函数 cout &lt;&lt; &quot;operator= : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = a.x, this-&gt;y = a.y; return ; &#125; void set(int x, int y) &#123; this-&gt;x = x, this-&gt;y = y; &#125; void seek() const &#123; seek_cnt += 1; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125; int S() const &#123; return seek_cnt; &#125; static int T() &#123; return Point::total_cnt; &#125; //类方法，所有对象共享一个,访问方法Point:: ~Point() &#123; //析构函数 cout &lt;&lt; &quot;destructor : &quot; &lt;&lt; this &lt;&lt; endl; Point::total_cnt -= 1; &#125; private: int x, y; mutable int seek_cnt; //如果想在const函数中修改一变量，就在声明变量时前面加一个mutable static int total_cnt; //类属性，在类外初始化，所有对象共享一个&#125;;int Point::total_cnt = 0;void test() &#123; Point a; cout &lt;&lt; Point::T() &lt;&lt; endl; return ;&#125;int main() &#123; Point a; //调用默认构造函数, total_cnt++ cout &lt;&lt; a.T() &lt;&lt; endl; //调用类方法, total_cnt = 1 //在test函数中：先调用默认构造函数, total_cnt++ //再调用类方法 total_cnt = 2 test(); //函数结束调用析构函数析构掉test中的a, total_cnt--, total_cnt = 1 Point b; //调用默认构造函数, total_cnt++ cout &lt;&lt; b.T() &lt;&lt; endl; //调用类方法， total_cnt = 2; Point c(3, 4); //先调用默认构造函数 total_cnt++，再调用有参构造函数 cout &lt;&lt; c.T() &lt;&lt; endl; //total_cnt = 3 Point d(3.4); //先调用默认构造函数 total_cnt++, 再调用转换构造函数 cout &lt;&lt; d.T() &lt;&lt; endl; //total_cnt = 4 //重点理解：5.6（先会调用默认构造函数 total_cnt++）调用转换构造函数生成匿名对象 //再调用赋值运算符赋值给c //赋值结束，5.6生成的匿名对象调用析构函数 total_cnt-- c = 5.6; cout &lt;&lt; c.T() &lt;&lt; endl; //total_cnt = 4 cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &amp;d &lt;&lt; endl; d.seek(); c.seek(); const Point e(6, 7); //const类型的类不能修改，只能调用const修饰的方法 e.seek(); e.seek(); e.seek(); e.seek(); cout &lt;&lt; e.S() &lt;&lt; endl; return 0;&#125; 返回值优化最初是“hug”先生成一个对象，拷贝给temp_atemp_a再生成一个匿名对象拷贝给a 三五法则","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"数据结构","slug":"2.DataStructure","date":"2020-08-06T10:40:46.543Z","updated":"2020-08-14T01:14:34.958Z","comments":true,"path":"2020/08/06/2.DataStructure/","link":"","permalink":"http://yoursite.com/2020/08/06/2.DataStructure/","excerpt":"","text":"数据结构 = 结构定义 + 结构操作 顺序表插入删除扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Vector &#123; int *data; int size, length;&#125; Vector;Vector *init(int n) &#123; Vector *vec = (Vector *)malloc(sizeof(Vector)); vec-&gt;data = (int *)malloc(sizeof(int) * n); vec-&gt;size = n; vec-&gt;length = 0; return vec;&#125;//扩容(倍增思想)int expand(Vector *vec) &#123; //vec-&gt;size *= 2; //vec-&gt;data = (int *)realloc(vec-&gt;data, sizeof(int) * vec-&gt;size); //return 1; int extr_size = vec-&gt;size; int *p; while(extr_size) &#123; p = (int *)realloc(vec-&gt;data, sizeof(int) * (vec-&gt;size + extr_size)); if(p) break; extr_size /= 2; &#125; if(p == NULL) return 0; vec-&gt;data = p; vec-&gt;size += extr_size; return 1;&#125;int insert(Vector *vec, int ind, int val) &#123; if(vec == NULL) return 0; if(ind &lt; 0 || ind &gt; vec-&gt;length) return 0; if(vec-&gt;length == vec-&gt;size) &#123; if(!expand(vec)) &#123; //printf(&quot;扩容失败\\n&quot;); return 0; &#125; printf(&quot;expand succeddfully! szie = %d\\n&quot;, vec-&gt;size); &#125; for(int i = vec-&gt;length; i &gt; ind; i--) &#123; vec-&gt;data[i] = vec-&gt;data[i - 1]; &#125; vec-&gt;data[ind] = val; vec-&gt;length++; return 1;&#125;int erase(Vector *vec, int ind) &#123; if(vec == NULL) return 0; if(ind &lt; 0 || ind &gt;= vec-&gt;length) return 0; for(int i = ind + 1; i &lt; vec-&gt;length; i++) &#123; vec-&gt;data[i - 1] = vec-&gt;data[i]; &#125; vec-&gt;length--; return 1;&#125;void output(Vector *vec) &#123; printf(&quot;Vector(%d) = [&quot;, vec-&gt;length); for(int i = 0; i &lt; vec-&gt;length; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, vec-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;void clear(Vector *vec) &#123; if(vec == NULL) return ; free(vec-&gt;data); free(vec); return ;&#125;int main() &#123; //随机种子 srand(time(0)); #define max_op 20 Vector *vec = init(1); int op, ind, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; ind = rand() % (vec-&gt;length + 3) - 1; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2:&#123; printf(&quot;insert %d at %d to Vector = %d\\n&quot;, val, ind, insert(vec, ind, val)); &#125; break; case 3: &#123; printf(&quot;erase item at %d from Vector = %d\\n&quot;, ind, erase(vec, ind)); &#125; break; &#125; output(vec); printf(&quot;\\n&quot;); &#125; clear(vec); return 0;&#125; 链表创建，初始化，插入，删除，遍历输出，反转，清空 普通链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;time.h&gt;#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct ListNode &#123; int data; struct ListNode *next;&#125; ListNode;typedef struct List &#123; ListNode head; int length;&#125; List;ListNode *getNewNode (int val) &#123; ListNode *p = (ListNode *)malloc(sizeof(ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;List *getLinkList() &#123; List *l = (List*)malloc(sizeof(List)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;int insert(List *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val); while(ind--) p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; l-&gt;length++; return 1;&#125;int erase(List *l, int ind) &#123; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; if(l == NULL) return 0; ListNode *p = &amp;(l-&gt;head), *q; while(ind--) p = p-&gt;next; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); l-&gt;length--; return 1;&#125;//链表反转void reverse(List *l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next, *q; l-&gt;head.next = NULL; while(p) &#123; q = p-&gt;next; p-&gt;next = l-&gt;head.next; l-&gt;head.next = p; p = q; &#125; return ;&#125;void output(List *l) &#123; printf(&quot;List(%d) = [&quot;, l-&gt;length); for(ListNode *p = l-&gt;head.next; p; p = p-&gt;next) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;NULL]\\n&quot;); return ;&#125;void clear_ListNode(ListNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear_List(List *l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next, *q; while(p) &#123; q = p-&gt;next; clear_ListNode(p); p = q; &#125; free(l); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 List *l = getLinkList(); int op, ind, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; ind = rand() % (l-&gt;length + 3) - 1; val = rand() % 100; switch(op) &#123; case 0: case 1: &#123; printf(&quot;insert %d at %d to List = %d\\n&quot;, val, ind, insert(l, ind, val)); &#125; break; case 2: &#123; printf(&quot;revere List:&quot;); reverse(l); output(l); &#125; break; case 3: &#123; printf(&quot;erase item at %d from List = %d\\n&quot;, ind, erase(l, ind)); &#125; break; &#125; output(l); printf(&quot;\\n&quot;); &#125; clear_List(l); return 0;&#125; 单向循环链表约瑟夫问题 定义一个遍历指针，初始指向 head，并让 head 指向空地址避免操作结束后变为野指针。 找到遍历指针往后数的第 n 次所指向的结点。 输出该结点的数据，更新遍历指针，然后删除该结点。 重复操作 2 直至只剩下最后一个结点。 输出最后一个结点并删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node *next;&#125;Node, *LinkedList;LinkedList insert(LinkedList head, Node *node, int index) &#123; if (head == NULL) &#123; if (index != 0) &#123; return head; &#125; head = node; head-&gt;next = head; return head; &#125; if (index == 0) &#123; node-&gt;next = head-&gt;next; head-&gt;next = node; return head; &#125; Node *current_node = head-&gt;next; int count = 0; while (current_node != head &amp;&amp; count &lt; index - 1) &#123; current_node = current_node-&gt;next; count++; &#125; if (count == index - 1) &#123; node-&gt;next = current_node-&gt;next; current_node-&gt;next = node; &#125; if (node == head-&gt;next) &#123; head = node; &#125; return head;&#125;// 请在下面实现输出函数 output_josephusvoid output_josephus(LinkedList head, int m) &#123; Node *current_node = head; head = NULL; while(current_node-&gt;next != current_node) &#123; for(int i = 1; i &lt; m; i++) &#123; current_node = current_node-&gt;next; &#125; printf(&quot;%d &quot;, current_node-&gt;next-&gt;data); Node *delete_node = current_node-&gt;next; current_node-&gt;next = current_node-&gt;next-&gt;next; free(delete_node); &#125; printf(&quot;%d\\n&quot;, current_node-&gt;data); free(current_node);&#125;int main() &#123; LinkedList linkedlist = NULL; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; Node *node = (Node *)malloc(sizeof(Node)); node-&gt;data = i; node-&gt;next = NULL; linkedlist = insert(linkedlist, node, i - 1); &#125; output_josephus(linkedlist, m); return 0;&#125; 双向链表双向循环链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node &#123; int data; struct Node *prior, *next;&#125; Node, *List;/*typedef struct List &#123; Node *head; int length;&#125; List;*/List insert(List head, Node *node) &#123; if(head == NULL) &#123; head = node; head-&gt;next = head; head-&gt;prior = head; return head; &#125; node-&gt;next = head-&gt;next; node-&gt;prior = head; head-&gt;next-&gt;prior = node; head-&gt;next = node; head = node; return head;&#125;void output(List head, int m) &#123; Node *p = head; int cnt = 0; while(p-&gt;data != m) &#123; p = p-&gt;next; &#125; //p = p-&gt;prior; Node *q = p; printf(&quot;%d&quot;, q-&gt;data); while(q-&gt;prior != p) &#123; q = q-&gt;prior; printf(&quot; %d&quot;, q-&gt;data); &#125; printf(&quot;\\n&quot;); return ;&#125;void clear(List l) &#123; Node *p = l-&gt;next, *q; while(p != l) &#123; q = p-&gt;next; free(p); p = q; &#125; free(l); return ;&#125;int main() &#123; List list = NULL; int n, m, a; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); Node *node = (Node *)malloc(sizeof(Node)); node-&gt;data = a; node-&gt;prior = NULL; node-&gt;next = NULL; list = insert(list, node); &#125; scanf(&quot;%d&quot;, &amp;m); output(list, m); clear(list); return 0;&#125; 链表环的问题 队列循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail, size, count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;size = n, q-&gt;head = 0, q-&gt;tail = 0, q-&gt;count = 0; return q;&#125;int empty(Queue *q) &#123; return !q-&gt;count;&#125;int front(Queue *q) &#123; return q-&gt;data[q-&gt;head];&#125;int push(Queue *q, int val) &#123; if(q == NULL) return 0; if(q-&gt;count == q-&gt;size) return 0; q-&gt;data[q-&gt;tail++] = val; //q-&gt;tail = (q-&gt;tail + 1) % q-&gt;size; if(q-&gt;tail == q-&gt;size) q-&gt;tail -= q-&gt;size; q-&gt;count++; return 1;&#125;void output(Queue *q) &#123; printf(&quot;Queue(%d) = [&quot;, q-&gt;count); for(int i= q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % (q-&gt;size)]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;size) q-&gt;head -= q-&gt;size; q-&gt;count--; return 1;&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 Queue *queue = init(max_op); int op, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to Queue = %d\\n&quot;, val, push(queue, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from Queue = &quot;, front(queue)); printf(&quot;%d\\n&quot;, pop(queue)); &#125; break; &#125; output(queue); printf(&quot;\\n&quot;); &#125; return 0;&#125; 单调队列 栈普通栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;typedef struct Stack &#123; int *data; int top, size;&#125; Stack;Stack *init(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;top = -1; s-&gt;size = n; return s;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int expand(Stack *s) &#123; int ext_size = s-&gt;size * 2; int *p; while(ext_size) &#123; p = (int *)realloc(s-&gt;data, sizeof(int) * (s-&gt;size + ext_size)); if(p) return 0; ext_size /= 2; &#125; if(p == NULL) return 0; s-&gt;data = p; s-&gt;size += ext_size; return 1;&#125;int push(Stack *s, int val) &#123; if(s == NULL) return 0; if(s-&gt;top + 1 == s-&gt;size)&#123; if(expand(s) == 0) return 0; &#125; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top -= 1; return 1;&#125;void output(Stack *s) &#123; printf(&quot;Stack(%d) = [&quot;, s-&gt;top + 1); for(int i = 0; i &lt;= s-&gt;top; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, s-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 int op, val; Stack *s = init(max_op); for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to Stack = %d\\n&quot;, val, push(s, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from Stack = &quot;, top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; &#125; output(s); printf(&quot;\\n&quot;); &#125; clear(s); return 0;&#125; 表达式求值 使用两个栈分别存储数值和运算符。 读取表达式字符，数值存入数值栈，运算符和栈顶运算符比较优先级。 通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算，计算结果入栈。 返回步骤 2，直至表达式全部读完。 弹出一个运算符和两个数值进行运算，计算结果存储数值栈。 当运算符栈不为空时，返回步骤 5，否则数值栈中剩余的最后一个元素就是表达式求值结果。 利用系统栈，即递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#define max_n 100#include &lt;inttypes.h&gt;int calc(const char *str, int l, int r) &#123; int prior = 0x3f3f3f3f - 1, temp = 0, pos = -1; for(int i = l; i &lt;= r; i++) &#123; int cur_prior = 0x3f3f3f3f; switch(str[i]) &#123; case &#x27;(&#x27; : temp += 100; break; case &#x27;)&#x27; : temp -= 100; break; case &#x27;+&#x27; : case &#x27;-&#x27; : cur_prior = temp + 1; break; case &#x27;*&#x27; : case &#x27;/&#x27; : cur_prior = temp + 2; break; case &#x27;^&#x27; : cur_prior = temp + 3; break; &#125; if(cur_prior &lt;= prior) &#123; pos = i; prior = cur_prior; &#125; &#125; if(pos == -1) &#123; int num = 0; for(int i = l; i &lt;= r; i++) &#123; if(str[i] &lt; &#x27;0&#x27; || str[i] &gt; &#x27;9&#x27;) continue; num = num * 10 + str[i] - &#x27;0&#x27;; &#125; return num; &#125; int a = calc(str, l, pos - 1); int b = calc(str, pos + 1, r); switch (str[pos]) &#123; case &#x27;+&#x27;: return a + b; case &#x27;-&#x27;: return a - b; case &#x27;*&#x27;: return a * b; case &#x27;/&#x27;: return a / b; case &#x27;^&#x27;: return (int)pow(a, b); &#125; return 0;&#125;int main() &#123; char str[max_n + 5] = &#123;0&#125;; while(scanf(&quot;%[^\\n]s&quot;, str) != EOF) &#123; getchar(); printf(&quot;%d\\n&quot;, calc(str, 0, strlen(str) - 1)); &#125; return 0;&#125; 单调栈 树二叉树性质： 二叉树遍历 递归的输出 1234567891011121314151617181920212223//前序遍历void pre_order(pNode p) &#123; if(p == NULL) return ; printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;l) pre_order(p-&gt;l); if(p-&gt;r) pre_order(p-&gt;r); return ;&#125;//中序遍历void in_order(pNode p) &#123; if(p == NULL) return ; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r); return ;&#125;//后序遍历void post_order(pNode p) &#123; if(p-&gt;l) post_order(p-&gt;l); if(p-&gt;r) post_order(p-&gt;r); printf(&quot;%c &quot;, p-&gt;data); return ;&#125; 二叉树的层次遍历孩子入队后爹出对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/**********************************************将广义表转成二叉树再以层次遍历输出**********************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char data; struct Node *l, *r;&#125; Node, *pNode;typedef struct Stack &#123; pNode *data; int top, size;&#125; Stack;typedef struct Queue &#123; pNode *data; int head, tail, size, cnt;&#125; Queue;//栈的操作void init_stack(Stack *s, int len) &#123; s-&gt;data = (pNode *)malloc(sizeof(pNode) * len); //??????????????????????????????????????????????????? s-&gt;top = -1; s-&gt;size = len; return ;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int push(Stack *s, pNode p) &#123; if(s-&gt;top + 1 &gt;= s-&gt;size) &#123; return 0; &#125; s-&gt;data[++(s-&gt;top)] = p; return 1;&#125;pNode top(Stack *s) &#123; if(empty(s)) return NULL; return s-&gt;data[s-&gt;top];&#125;int pop(Stack *s)&#123; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;//队列操作void init_queue(Queue *q, int len) &#123; q-&gt;data = (pNode*)malloc(sizeof(pNode) * (2 * len)); q-&gt;size = len; q-&gt;head = 0; q-&gt;tail = -1; q-&gt;cnt = 0; return ;&#125;int empty_queue(Queue *q) &#123; return q-&gt;tail &lt; q-&gt; head; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;int push_queue(Queue *q, pNode p) &#123; if(q-&gt;tail &gt;= q-&gt;size) return 0; q-&gt;data[++(q-&gt;tail)] = p; //xxxxxxxxxxxxxxxxxxxxxxxxtailduojialexxxxxxxxxxxxxxxxxxx q-&gt;cnt++; return 1;&#125;int pop_queue(Queue *q) &#123; if(empty_queue(q)) return 0; q-&gt;head++; return 1;&#125;void clear_queue(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;//树的操作Node *get_node(char c) &#123; Node *node = (Node *)malloc(sizeof(Node)); //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx node-&gt;data = c; node-&gt;l = node-&gt;r = NULL; return node;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; if(node-&gt;l) clear_node(node-&gt;l); if(node-&gt;r) clear_node(node-&gt;r); free(node); return ;&#125;pNode built_tree(char *str, int *node_num) &#123; pNode temp = NULL, current_root = NULL; Stack *s = (Stack *)malloc(sizeof(Stack)); //? init_stack(s, strlen(str)); int flag = 0; while(str[0]) &#123; switch(str[0]) &#123; case &#x27;(&#x27;: push(s, temp); flag = 0; temp = NULL; break; case &#x27;,&#x27;: flag = 1; temp = NULL; break; case &#x27;)&#x27;: current_root = top(s); pop(s); break; case &#x27; &#x27;: break; default: temp = get_node(str[0]); if(!empty(s) &amp;&amp; flag == 0) &#123; s-&gt;data[s-&gt;top]-&gt;l = temp; //xxxxxxxxxxxxxx &#125; else if(!empty(s) &amp;&amp; flag == 1)&#123; s-&gt;data[s-&gt;top]-&gt;r = temp; //xxxxxxxxxxxx top(s)-&gt;r=.. 不对 xxxxxxxxxxxxxxx &#125; ++(*node_num); break; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; str++; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx忘写，导致我关机两次 &#125; if(temp &amp;&amp; !current_root) current_root = temp; //xxxx*** clear(s); //忘写 return current_root;&#125;//✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍ 层次遍历输出 ✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍void output(pNode node, int node_num) &#123; if(node_num == 0) return ; printf(&quot;%c&quot;, node-&gt;data); Queue *q = (Queue *)malloc(sizeof(Queue)); init_queue(q, node_num); push_queue(q, node); while(!empty_queue(q)) &#123; if(q-&gt;data[q-&gt;head]-&gt;l == NULL &amp;&amp; q-&gt;data[q-&gt;head]-&gt;r == NULL) &#123; pop_queue(q); continue; &#125; if(q-&gt;data[q-&gt;head]-&gt;l) &#123; push_queue(q, q-&gt;data[q-&gt;head]-&gt;l); printf(&quot; %c&quot;, q-&gt;data[q-&gt;head]-&gt;l-&gt;data); &#125; if(q-&gt;data[q-&gt;head]-&gt;r) &#123; push_queue(q, q-&gt;data[q-&gt;head]-&gt;r); printf(&quot; %c&quot;, q-&gt;data[q-&gt;head]-&gt;r-&gt;data); &#125; pop_queue(q); &#125; printf(&quot;\\n&quot;); clear_queue(q); return ;&#125;void in_order(pNode p) &#123; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c&quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r);&#125;int main()&#123; char str[100]; scanf(&quot;%[^\\n]s&quot;, str); int node_num = 0; pNode tree = built_tree(str, &amp;node_num); output(tree, node_num); clear_node(tree); return 0;&#125; 二叉树加线索化后孩子若为空就让右孩子指针域指向其后继 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define NORMAL 0#define THREAD 1typedef struct Node &#123; int data; struct Node *lchild, *rchild; int ltag, rtag;&#125; Node;Node *getNewNode(int val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; p-&gt;ltag = NORMAL; p-&gt;rtag = NORMAL; return p;&#125;Node *insert(Node *root, int val) &#123; if (root == NULL) return getNewNode(val); if (root-&gt;data == val) return root; if (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val); else root-&gt;rchild = insert(root-&gt;rchild, val); return root;&#125;void build_thread(Node *root) &#123; if (root == NULL) return ; static Node *pre = NULL; build_thread(root-&gt;lchild); if (root-&gt;lchild == NULL) &#123; root-&gt;lchild = pre; root-&gt;ltag = THREAD; &#125; if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) &#123; pre-&gt;rchild = root; pre-&gt;rtag = THREAD; &#125; pre = root; build_thread(root-&gt;rchild); return ;&#125;Node *most_left(Node *p) &#123; while (p &amp;&amp; p-&gt;ltag == NORMAL &amp;&amp; p-&gt;lchild != NULL) p = p-&gt;lchild; return p;&#125;void output(Node *root) &#123; Node *p = most_left(root); while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); if (p-&gt;rtag == THREAD) &#123; p = p-&gt;rchild; &#125; else &#123; p = most_left(p-&gt;rchild); &#125; &#125; return ;&#125;void in_order(Node *root) &#123; if (root == NULL) return ; if (root-&gt;ltag == NORMAL) in_order(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); if (root-&gt;rtag == NORMAL) in_order(root-&gt;rchild); return ;&#125;void clear(Node *root) &#123; if (root == NULL) return ; if (root-&gt;ltag == NORMAL) clear(root-&gt;lchild); if (root-&gt;rtag == NORMAL) clear(root-&gt;rchild); free(root); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 Node *root = NULL; for (int i = 0; i &lt; max_op; i++) &#123; int val = rand() % 100; root = insert(root, val); &#125; build_thread(root); output(root), printf(&quot;\\n&quot;); in_order(root), printf(&quot;\\n&quot;); clear(root); return 0;&#125; 广义表和二叉树1.由广义表创建二叉树 借助栈，栈里元素存节点的地址 1234567891011121314151617181920212223242526272829设置一个标记变量 flag，初始为 0；设置一个标记节点 temp,当前层父节current_root(即栈顶元素，每次出栈时赋值给current_root)循环遍历存储广义表的字符串 str：如果 str[i] 是 &#x27;(&#x27;： (遇到&#x27;(&#x27;此时的p才能当爹，因为&#x27;(&#x27;后面就开始是他的孩子了，这时让他进栈) 则设置 flag 为 0；(因为&#x27;(&#x27;后面第一个是他左孩子，要用flag == 0来识别) 把 temp 压入栈中。 temp = NULL;否则如果 str[i] &#x27;,&#x27;： 则设置flag为 1; (因为&#x27;，&#x27;后面一个是他右孩子，要用flag == 1来识别) temp = NULL;否则如果 str[i] 是 &#x27;)&#x27;： 则栈顶元素出栈;(当前栈顶元素出栈) current_root = top(s); pop(s);否则如果 str[i] 是 &#x27; &#x27;：break;否则如果 str[i] 是一个字母: 用节点 temp 来存储： 如果 flag 为 0： 将 temp 作为栈顶节点的左孩子； 如果 k 为 1： 将 temp 作为栈顶节点的右孩子； (另外可以用一个传出参数来记录节点个数) 最后要判断栈是否为空，若为空说明没遇到&#x27;(&#x27;,则只有一个根结点，直接把temp赋值给current_root 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node&#123; char data; struct Node *l, *r;&#125;Node, *pNode;typedef struct Stack&#123; pNode *data; int top, size;&#125; Stack;void init_stack(Stack *s, int len) &#123; s-&gt;data = (pNode *)malloc(sizeof(pNode) * len); s-&gt;size = len; s-&gt;top = -1; return ;&#125;int push(Stack *s, pNode p) &#123; if(s-&gt;top + 1 &gt;= s-&gt;size) return 0; s-&gt;data[++(s-&gt;top)] = p; return 1;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;pNode top(Stack *s) &#123; if(empty(s)) return NULL; return s-&gt;data[s-&gt;top];&#125;int pop(Stack *s) &#123; if(empty(s)) return 0; s-&gt;top -= 1; return 1;&#125;void clear_stack(Stack *s)&#123; if(s == NULL) return; free(s-&gt;data); free(s); return ;&#125;Node* get_node(char c) &#123; Node* p = (pNode)malloc(sizeof(Node)); p-&gt;data = c; p-&gt;l = p-&gt;r = NULL; return p;&#125;void clear_node (Node *node) &#123; if(node == NULL) return ; if(node-&gt;l) clear_node(node-&gt;l); if(node-&gt;r) clear_node(node-&gt;r); free(node); return ;&#125;pNode build(char *str, int *tree_node_num) &#123; pNode temp = NULL, current_root = NULL; Stack *s = (Stack *)malloc(sizeof(Stack)); init_stack(s, strlen(str)); int flag = 0; while(str[0]) &#123; switch (str[0]) &#123; case &#x27;(&#x27; : flag = 0; push(s, temp); temp = NULL; break; case &#x27;,&#x27; : flag = 1; temp = NULL; break; case &#x27;)&#x27; : current_root = top(s); pop(s); break; case &#x27; &#x27;: break; default : temp = get_node(str[0]); if(!empty(s) &amp;&amp; flag == 0) &#123; s-&gt;data[s-&gt;top]-&gt;l = temp; &#125; else if(!empty(s) &amp;&amp; flag == 1) &#123; s-&gt;data[s-&gt;top]-&gt;r = temp; &#125; ++(*tree_node_num); break; &#125; str++; &#125; if(temp &amp;&amp; !current_root) current_root = temp; //一个根结点 clear_stack(s); return current_root;&#125;void pre_order(pNode p) &#123; if(p == NULL) return ; printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;l) pre_order(p-&gt;l); if(p-&gt;r) pre_order(p-&gt;r); return ;&#125;void in_order(pNode p) &#123; if(p == NULL) return ; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r); return ;&#125;void post_order(pNode p) &#123; if(p-&gt;l) post_order(p-&gt;l); if(p-&gt;r) post_order(p-&gt;r); printf(&quot;%c &quot;, p-&gt;data); return ;&#125;int main() &#123; char str[35] = &#123;0&#125;, c; scanf(&quot;%[^\\n]s&quot;, str); int tree_node_num = 0; pNode tree = build(str, &amp;(tree_node_num)); printf(&quot;前序:&quot;); pre_order(tree); printf(&quot;\\n&quot;); printf(&quot;中序:&quot;); in_order(tree); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); post_order(tree); printf(&quot;\\n&quot;); return 0;&#125; 2.二叉树生成广义表 输出节点存储的值； 如果左孩子不为空： 输出 &quot;(&quot;； 递归输出左子树； 如果右孩子为空： 输出 &quot;)&quot;。 如果右孩子不为空： 如果左孩子为空： 输出 &quot;(&quot;。 输出 “,”； 递归输出右子树； 输出 &quot;)&quot;。 1234567891011121314151617void output(Node *p) &#123; if(p == NULL) return ; printf(&quot;%c&quot;, p-&gt;data); if(p-&gt;l == NULL &amp;&amp; p-&gt;r == NULL) &#123; return ; &#125; printf(&quot;(&quot;); if(p-&gt;l) &#123; output(p-&gt;l); &#125; if(p-&gt;r) &#123; printf(&quot;,&quot;); output(p-&gt;r); &#125; printf(&quot;)&quot;); return ; &#125; 堆和优先队列概述 插入操作： 把新元素保存在数组的最后。 找到新插入元素的父节点位置。 将新元素与父节点比较大小。 若新插入的元素与其父节点大小不符合堆序性则交换它和父节点的位置，并回到步骤 2；若符合则插入操作完成。 删除操作： 将堆顶元素和最后一个元素交换。 删除堆的最后一个元素。 自顶向下调整元素的位置，使之满足堆序性。 堆排序：(将大根堆有小到大排序为例：) 将变量 i 设为堆末下标。 交换堆顶和第 i 个元素。 自上到下调整堆顶到第 i 个元素之间的堆结构，使之保持堆序性。 将 i 前移一位，重复步骤 2，直至 i 等于 1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//计蒜客写法#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Heap &#123; int *data, size;&#125; Heap;void init(Heap *h, int length_input) &#123; h-&gt;data = (int *)malloc(sizeof(int) * length_input); h-&gt;size = 0;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;void push(Heap *h, int value) &#123; h-&gt;data[h-&gt;size] = value; int current = h-&gt;size; int father = (current - 1) / 2; while (h-&gt;data[current] &gt; h-&gt;data[father]) &#123; swap(&amp;h-&gt;data[current], &amp;h-&gt;data[father]); current = father; father = (current - 1) / 2; &#125; h-&gt;size++;&#125;void output(Heap *h) &#123; for (int i = 0; i &lt; h-&gt;size; i++) &#123; printf(&quot;%d &quot;, h-&gt;data[i]); &#125; printf(&quot;\\n&quot;);&#125;int top(Heap *h) &#123; return h-&gt;data[0];&#125;void update(Heap *h, int pos, int n) &#123; int lchild = 2 * pos + 1, rchild = 2 * pos + 2; int max_value = pos; if (lchild &lt; n &amp;&amp; h-&gt;data[lchild] &gt; h-&gt;data[max_value]) &#123; max_value = lchild; &#125; if (rchild &lt; n &amp;&amp; h-&gt;data[rchild] &gt; h-&gt;data[max_value]) &#123; max_value = rchild; &#125; if (max_value != pos) &#123; swap(&amp;h-&gt;data[pos], &amp;h-&gt;data[max_value]); update(h, max_value, n); &#125;&#125;void pop(Heap *h) &#123; swap(&amp;h-&gt;data[0], &amp;h-&gt;data[h-&gt;size - 1]); h-&gt;size--; update(h, 0, h-&gt;size);&#125;// 请在下面实现堆排序函数 heap_sortvoid heap_sort(Heap *h) &#123; for(int i = h-&gt;size - 1; i &gt;= 1; i--) &#123; swap(&amp;h-&gt;data[i], &amp;h-&gt;data[0]); update(h, 0, i); &#125;&#125;void clear(Heap *h) &#123; free(h-&gt;data); free(h);&#125;int main() &#123; int arr[10] = &#123; 12, 9, 30, 24, 30, 4, 55, 64, 22, 37 &#125;; Heap *heap = (Heap *)malloc(sizeof(Heap)); init(heap, 100); for (int i = 0; i &lt; 10; i++) &#123; push(heap, arr[i]); &#125; output(heap); printf(&quot;%d\\n&quot;, top(heap)); pop(heap); output(heap); heap_sort(heap); output(heap); clear(heap); return 0;&#125; 线性建堆-堆排序 上面入堆操作是从下向上，每次进来一个放堆尾，再去维护，维护时反复跟父节点比较，Olog(n) 初始化建堆： 其实可以直接把所有元素先放数组里再一起去建堆，这时采用上面删除元素时自上而下的操作，从第n/2个元素到第一个元素每个元素(即非叶子节点)进行自上而下操作(下虑)，即反复让其与两个子节点比较直到不满足条件，所有点操作完就建好了一个堆O(n) 维护堆(重建堆)： 堆排序和建堆相同的操作，只不过这次是去维护堆，每次将堆顶元素(最值元素)跟倒数第i位交换堆就破环了再去将堆顶元素自上而下下虑维护堆，依次将所有堆顶元素放到后面就完成了排序nlog(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void updata(int *arr, int ind, int n) &#123; //int temp = ind; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx写循环内 while((ind &lt;&lt; 1) &lt;= n) &#123; //xxxxxxxxxxxxxxxxxxxxxx int temp = ind, l = ind * 2, r = ind * 2 + 1; if(arr[l] &gt; arr[temp]) &#123; temp = l; &#125; if(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) &#123; //xxxxxxxx temp = r; &#125; if(temp == ind) break; //xxxxxxxxxxxxxxxxxxxxxxx漏写 swap(arr[ind], arr[temp]); ind = temp; &#125;&#125;void heap_sort(int *arr, int n) &#123; arr -= 1; //初建堆 for(int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; updata(arr, i, n); &#125; //排序重建堆 for(int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]); updata(arr, 1, i - 1); &#125; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); int n, val; scanf(&quot;%d&quot;, &amp;n); int *arr = (int *)malloc(sizeof(int) * n); for(int i = 0; i &lt; n; i++) &#123; val = rand() % 100; arr[i] = val; &#125; output(arr, n); heap_sort(arr, n); output(arr, n); free(arr); return 0;&#125; 优先队列其实就是堆 普通队列 (最大/最小)堆 尾部入队 尾部可以插入 头部入队 头部可以弹出 先进先出 每次出对权值(最大/最小的元素) 数组实现 数组实现，逻辑上看成堆 哈希表哈希函数 1.直接寻址法。取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数） 2.数字分析法。分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 3.平方取中法。取关键字平方后的中间几位作为散列地址。 4.折叠法。将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 5.随机数法。选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。 6.除留余数法。取关键字被某个不大于表长m的数p除后所得的余数为散列地址。即 $H(key) = key % p,p&lt;=m$.不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。 解决冲突的办法 1. 开放定址法(常用) 如果发⽣冲突，那么就使⽤某种策略寻找下⼀存储地址，直到找到⼀个不冲突的地址或者找到关键字，否则⼀直按这种策略继续寻找。如果冲突次数达到了上限则终⽌程序，表⽰关键字不存在哈希表⾥。常⻅的策略有这⼏种： 线性探测法，如果当前的冲突位置为 d，那么接下来⼏个探测地址为d + 1，d + 2, 等，也就是从冲突地址往后⾯⼀个⼀个探测 线性补偿探测法，它形成的探测地址为 d + m，d + 2 * m ，d + 3 * m等，与线性探测法不同，这⾥的查找单位不是 1，而是 m，为了能遍历到哈希表⾥所有位置，我们设置m 和表⻓szie互质； 随机探测法，这种⽅法和前两种⽅法类似，这⾥的查找单位不是⼀个固定值，而是⼀个随机序列。 ⼆次探测法，它形成的探测地址为 d + 1^2，d - 1^2 ，d + 2^2，d - 2^2 等，这种⽅法在冲突位置左右跳跃着寻找探测地址。 2. 拉链法(常用) 该⽅法将所有哈希地址相同的结点构成⼀个单链表，单链表的头结点存在哈希数组⾥。链地址法常出现在经常插⼊和删除的情况下。优点：不会出现“堆聚”现象，哈希地址不同的关键字不会发⽣冲突；不需要重建哈希表，在开放地址法中，如果哈希表⾥存满关键字了就需要扩充哈希表然后重建哈希表 3. 再哈希法 Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。 4. 建立公共溢出区 冲突次数大于表长的一般时认为堆聚，需要重建 1.开辟一段和当前哈希表等大的临时存储空间。 ​ 2.将原哈希表里的关键字一一复制到临时数组里。 ​ 3.申请一个大小是现在两倍的新的存储空间，释放原空间。 ​ 4.将新空间里的存储地址初始化。 ​ 5.将关键字从临时数组复制到新的空间，释放临时空间。 字符串哈希函数 常见字符串哈希函数：BKDRHash ， APHash ， DJBHash ， JSHash ， RSHash 123456//BKDRHash 法int BKDRHash(char *str) &#123; int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; return hash &amp; 0x7fffffff;&#125; 拉链法写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;typedef struct Node &#123; char *str; struct Node *next;&#125; Node;typedef struct HashTable &#123; Node **data; int size;&#125; HashTable;Node *init_node(char *str, Node *head) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;str = strdup(str); p-&gt;next = head; return p;&#125;HashTable *init_hashtable(int n) &#123; HashTable *h = (HashTable *)malloc(sizeof(HashTable)); h-&gt;size = n &lt;&lt; 1; h-&gt;data = (Node **)calloc(h-&gt;size, sizeof(Node *)); return h;&#125;int BKDRHash(char *str) &#123; int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; return hash &amp; 0x7fffffff;&#125;int insert(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size; h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); return 1;&#125;int search(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size; Node *p = h-&gt;data[ind]; while(p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; //条件不能出错xxxxxxxxxxx return p != NULL;&#125; void clear_node(Node *node) &#123; if(node == NULL) return ; Node *p = node, *q; while(p) &#123; q = p-&gt;next; free(p-&gt;str); free(p); p = q; &#125; free(q); return ;&#125;void clear_hashtable(HashTable *h) &#123; if(h == NULL) return ; for(int i = 0; i &lt; h-&gt;size; i++) clear_node(h-&gt;data[i]); free(h-&gt;data); free(h); return ;&#125;int main() &#123; int op; #define max_n 100 char str[max_n + 5]; HashTable *h = init_hashtable(max_n + 5); while(~scanf(&quot;%d%s&quot;, &amp;op, str)) &#123; switch(op) &#123; case 0: printf(&quot;insert %s to hash to table\\n&quot;, str); insert(h, str); break; case 1: printf(&quot;search %s from has table result = %d\\n&quot;, str, search(h, str)); break; &#125; &#125; clear_hashtable(h); return 0;&#125; 排序稳定排序： 常见稳定排序:插入排序，冒泡排序，归并排序 插入排序 基本思想：是将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出第⼀个元素，插⼊到已排序部分的对应位置中，直到全部记录都插⼊到已排序部分中。总体时间复杂度O(n^2); 冒泡排序 基本思想：将n个元素比较$n - 1$趟，每一趟比较$n - i$次(即待排元素个数减一)，每一趟都将待排中最大的排到了最后面。时间复杂度O(n^2) 归并排序 基本思想：将两个有序表合成一个有序表，两个有序表如何得到？将原表从中间分成两半，递归的求两边，最后进行一下合并。归并一共进行$O(logn)$层归并，每层时间复杂度$O(n)$,总体时间复杂度$O(nlogn)$,每次合并时要开辟临时空间存储，然后再复制过去，空间复杂度$O(n)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define swap(a, b) &#123;\\ a ^= b; b ^= a; a ^= b;\\&#125;//插入排序void insert_sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j-1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125;//冒泡排序void bubble_sort(int *num, int n) &#123; int times = 1; for(int i = 1; i &lt; n &amp;&amp; times; i++) &#123; times = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; swap(num[j], num[j + 1]); times++; &#125; &#125; &#125; return ;&#125;//归并排序void merge_sort(int *num, int l, int r) &#123; //if(l == r) return ; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[l] &gt; num[r]) &#123; swap(num[l], num[r]); &#125; return ; &#125; int mid = (l + r) &gt;&gt; 1; merge_sort(num, l, mid); merge_sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, k = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[k++] = num[p1++]; &#125; else &#123; temp[k++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125; 非稳定排序： 常见的不稳定排序算法有选择排序(selection sort)、快速排序(quick sort)、堆排序(heap sort)、希尔排序(shell sort) 选择排序 基本思想：分成已排序区(在前)和待排序区,每次从待排序区中找出最小的放已排序的最后面即放在待排序的第一位。或这样理解，一趟都将待排序区的最小值放最前面(跟待排序第一个数交换)，待排序区的元素每趟都会少一个。因为在找待排序区中最小元素时都是将后面的元素跟第一个比较，找到后跟第一个数交换位置，因此可知会打乱后面与第一个数相等的数他俩的相对位置，所以选择排序是不稳定的。也有可能第一个数就是待排区中的最小的数，这时候在写swap函数时就不能用异或运算来写，同一个地址的元素异或交换就变成0了。时间复杂度O(n^2) 快速排序 基本思想：选一个基准值,利用双指针将所有小于基准值的元素放到左边，所有大于基准值的元素放到右边，再递归的将左右两边元素分别排序。平均时间复杂度O(log(n)),最坏O(n^2) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;//函数测试框架，稳定排序一样用法#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\&#125;//选择排序void select_sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[j] &lt; num[ind]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125;//快速排序void quick_sort(int *num, int l, int r) &#123; if(r &lt; l) return ; int x = l, y = r, pivot = num[l]; while(x &lt; y) &#123; //先从右边开始找第一个小于Pivot的值 while(x &lt; y &amp;&amp; num[y] &gt;= pivot) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt;= pivot) x++; if(x &lt; y) num[y--] = num[x]; &#125; num[x] = pivot; quick_sort(num, l, x - 1); quick_sort(num, x + 1, r); return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *num, int n) &#123; printf(&quot;[ &quot;); for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, num[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define max_op 15 int arr[max_op]; randint(arr, max_op); TEST(arr, max_op, select_sort, num, max_op); TEST(arr, max_op, quick_sort, num, 0, max_op - 1); return 0;&#125; 查找二分查找：解决的是将问题规模减小 普通情况： 在有序序列找一个数 1234567891011//1 3 5 7 9 10 ......int binary_search1(int *num, int n, int x) &#123; int head = 0, tail = n - 1, mid; while(head &lt;= tail) &#123; mid = (head + tail) &gt;&gt; 1; if(num[mid] == x) return mid; if(num[mid] &lt; x) head = mid + 1; else tail = mid - 1; &#125; return -1;&#125; 000000011111情况: 找第一个1的位置 123456789int binary_search2(int *num, int n) &#123; int head = 0, tail = n, mid; // 一定存在答案的话，应该可以tail = n - 1开始。。 while(head &lt; tail) &#123; mid = (head + tail) &gt;&gt; 1; //重点注意 if(num[mid] == 1) tail = mid; else head = mid + 1; &#125; return head == n ? -1 : head;&#125; ① $mid = (head + tail) / 2$ 如果此时 0 0 0 0 0 0 1 1 1 1 ↑ ↑ l r 下一次 mid = (l + r) / 2 == l 更新 r = mid = l; 正好得到答案不会死循环，所以求 mid 时 l + r 不用再加1 11111110000的情况则不同(下面分析) ② $head = mid + 1$ 12345000000011111 ↑head &#x3D; mid + 1;如果此时 mid 指向的是0那么他一定不是答案，所以舍去 mid 及前面的 ③ $tail = mid$ 12345000000011111 ↑tail &#x3D; mid;如果此时 mid 指向的是1那么他 有可能 是答案，所以留下 mid， 舍弃mid后面的 111111111100000情况 求最后一个1的位置 12345678910int binary_search3(int *num, int n) &#123; int head = -1, tail = n - 1, mid; //一定存在答案的话，应该可以head = 0开始。。 while(head &lt; tail) &#123; mid = (head + tail + 1) &gt;&gt; 1; //重点关注 if(num[mid] == 1) &#123; head = mid; &#125; else tail = mid - 1; &#125; return head;&#125; ① $mid = (head + tail + 1) / 2$ 12345678910如果此时1 1 1 1 1 1 1 1 0 0 0 0 ↑ ↑ l r如果 mid &#x3D; (l + r) &#x2F; 2;那么下一次 mid &#x3D; (l + r) &#x2F; 2 &#x3D;&#x3D; l; 更新 l &#x3D; mid &#x3D; l; l 还是 l这时就会死循环 所以应该 mid &#x3D; (head + tail + 1) &#x2F; 2； ② $head = mid$ 1234511111110000000000000 ↑head &#x3D; mid;如果此时 mid 指向的 1 ,那么他有可能是答案，所以舍去 mid 前面的，留下 mid ③ $tail = mid$ 123451111110000000 ↑tail &#x3D; mid - 1;如果此时 mid 指向的是 0 那么他一定不是答案，所以舍弃 mid 及后面的 三分查找： 在一个单调函数中，用二分查找精确求解中某一点的值。如果函数是一个 凸性函数（在某一点左侧，函数递增，在该点右侧，函数递减，该点称为极大值点）或者 凹性函数（在某一点左侧，函数递减，在该点右侧，函数递增，该点称为极小值点）求最值就要用到三分查找 三分查找每次比较后，都会将区间长度缩小到原来的$2/3$ 。时间复杂度Olog(n); 123456789101112131415161718192021222324252627//凸函数代码//凹函数只需要把10，16行大于改成小于即可#include &lt;stdio.h&gt;int find_max(int *data, int length) &#123; int left = 0, right =length - 1; while(right - left &gt;= 2) &#123; int m1 = left + (right - left) / 3; int m2 = right - (right - left + 2) / 3; //尽量让m2靠近极值点 if(data[m1] &gt;= data[m2]) &#123; right = m2; &#125; else &#123; left = m1 + 1;//尽量让m1靠近极值点 &#125; &#125; if(data[left] &gt;= data[right]) &#123; return left; &#125; else &#123; return right; &#125;&#125;int main() &#123; int a[5] = &#123;1, 2, 7, 5, 4&#125;; printf(&quot;%d\\n&quot;, find_max(a, 5)); return 0;&#125; 平衡二叉查找树二叉排序树又称二叉搜索树 **左子树 &lt; 根结点 ** 右子树 &gt; 根结点 用途: 解决排名相关的检索需求 ⼆叉查找树插⼊查找的效率都是 O(log n)，最坏情况下是 O(n) 二叉查找树插入 小于根结点插左子树，大于根结点插右子树 二叉查找树删除 删除叶子节点 删除出度为1的节点 如图删除3 ➡ 删除出度为2的节点 先找到前驱或后继，然后替换后转换为出度为1的节点问题 如图删除20 ➡➡ ➡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;typedef struct Node &#123; int key; struct Node *lchild, *rchild;&#125; Node;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Node *insert(Node *root, int key) &#123; if(root == NULL) return getNewNode(key); if(root-&gt;key == key) return root; if(key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key); else root-&gt;rchild = insert(root-&gt;rchild, key); return root;&#125;Node *predecessor(Node *root) &#123; Node *temp = root-&gt;lchild; while(temp-&gt;rchild) temp = temp-&gt;rchild; return temp;&#125;//删除节点重要！Node *erase(Node *root, int key) &#123; if(root == NULL) return root; if(key &lt; root-&gt;key) root-&gt;lchild = erase(root-&gt;lchild, key); else if(key &gt; root-&gt;key) root-&gt;rchild = erase(root-&gt;rchild, key); else &#123; //度为一或0 if(root-&gt;lchild == NULL || root-&gt;rchild == NULL) &#123; Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild; free(root); return temp; &#125; else &#123; //度为2的节点 Node *temp = predecessor(root); root-&gt;key = temp-&gt;key; root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key); &#125; &#125; return root;&#125;void __in_order(Node *root) &#123; if(root == NULL) return ; __in_order(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;key); __in_order(root-&gt;rchild); return ;&#125;void in_order(Node *root) &#123; printf(&quot;in order output: &quot;); __in_order(root); printf(&quot;\\n&quot;);&#125;void clear(Node *root) &#123; if(root == NULL) return ; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return ;&#125;int main() &#123; int op, val; Node *root = NULL; while(~scanf(&quot;%d%d&quot;, &amp;op, &amp;val)) &#123; switch(op) &#123; case 1: root = insert(root, val); break; case 2: root = erase(root, val); break; &#125; in_order(root); &#125; clear(root); return 0;&#125; 平衡二叉查找树AVL树 平衡条件：每个节点左右子树最大高度差不超过1 四种旋转操作： LL型 LR型：首先是左子树比右子树高度差为2了，又左子树的右子树比左子树的左子树高，此时需要先站在左孩子处进行小左旋，再站在当前节点进行大右旋 RL型 RR型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define H(root) (root)-&gt;h#define L(root) (root)-&gt;l#define R(root) (root)-&gt;r#define K(root) (root)-&gt;keytypedef struct Node &#123; int key, h; struct Node *l, *r;&#125; Node;Node __NIL;#define NIL (&amp;__NIL)__attribute__((constructor))void init_NIL() &#123; NIL-&gt;key = NIL-&gt;h = 0; NIL-&gt;l = NIL-&gt;r = NIL; return ;&#125;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;h = 1; p-&gt;l = p-&gt;r = NIL; return p;&#125;void update_height(Node *root) &#123; root-&gt;h = H(L(root))&gt; H(R(root)) ? H(L(root)) : H(R(root)) + 1;&#125;Node *left_rotate(Node *root) &#123; Node *temp = root-&gt;r; root-&gt;r = temp-&gt;l; temp-&gt;l = root; update_height(root); update_height(temp); return temp;&#125;Node *right_rotate(Node *root) &#123; Node *temp = root-&gt;l; root-&gt;l = temp-&gt;r; temp-&gt;r = root; update_height(root); update_height(temp); return temp;&#125;Node *maintain(Node *root) &#123; if (abs(H(L(root)) - H(R(root))) &lt;= 1) return root; if (H(L(root)) &gt; H(R(root))) &#123; if(H(R(L(root))) &gt; H(L(L(root)))) &#123; root-&gt;l = left_rotate(root-&gt;l); &#125; root = right_rotate(root); &#125; else &#123; if(H(L(R(root))) &gt; H(R(R(root)))) &#123; root-&gt;l = right_rotate(root-&gt;l); &#125; root = left_rotate(root); &#125; return root;&#125;Node *insert(Node *root, int key) &#123; if (root == NIL) return getNewNode(key); if (root-&gt;key == key) return root; if (root-&gt;key &gt; key) &#123; root-&gt;l = insert(root-&gt;l, key); &#125; else root-&gt;r = insert(root-&gt;r, key); update_height(root); //插入一节点就要更新树高 return maintain(root);&#125;void clear(Node *root) &#123; if (root == NIL) return ; clear(root-&gt;l); clear(root-&gt;r); free(root);&#125; Node *predeccessor(Node *root) &#123; Node *temp = root-&gt;l; while (temp-&gt;r != NIL) temp = temp-&gt;r; return temp;&#125;Node *erase(Node *root, int key) &#123; if (root == NIL) return root; if (root-&gt;key &gt; key) root-&gt;l = erase(root-&gt;l, key); else if (root-&gt;key &lt; key) &#123; root-&gt;r = erase(root-&gt;r, key); &#125; else &#123; if (root-&gt;l == NIL || root-&gt;r == NIL) &#123; Node *temp = root-&gt;l == NIL ? root-&gt;r : root-&gt;l; free(root); return temp; &#125; else &#123; Node *temp = predeccessor(root); root-&gt;key = temp-&gt;key; root-&gt;l = erase(root-&gt;l, temp-&gt;key); &#125; &#125; update_height(root); return maintain(root);&#125;void output(Node *root) &#123; if (root == NIL) return ; printf(&quot;(%d %d %d)\\n&quot;, K(root), K(L(root)), K(R(root))); output(root-&gt;l); output(root-&gt;r); return ;&#125;int main() &#123; #define MAX_OP 20 Node *root = NIL; for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; root = insert(root, val); &#125; output(root); int val; while(~scanf(&quot;%d&quot;, &amp;val)) &#123; root = erase(root, val); printf(&quot;erase %d from tree&quot;, val); output(root); &#125; return 0;&#125; 红黑树五个平衡条件 每个结点要么是红色，要么是黑色； 根结点是黑色； 叶结点（NIL）是黑色； 如果一个结点是红色，则它的两个子节点都是黑色的； 从根结点出发到所有叶结点的路径上，均包含相同数目的黑色结点。 提示：调整时要明确哪些点的颜色是确定的哪些是不确定的，调整前后要保证这个子树上面的黑色数量没有改变 插入调整(两种情况)==站在祖父节点往下看是否有颜色冲突(看儿子和孙子是不是同时为红色)== 叔叔红 方案：直接红上顶 叔叔黑(我位置有4种情况) LR型：先小左旋(注意观察小左旋并不影响路径上黑色节点数量)，转化为LL型 LL型：直接大右旋，再调帽子为红黑黑或黑红红 RR、RL和上面一样 删除调整(三种情况)删除操作站在父节点往下看 分析删除只有一个孩子的结点的情况：如果要删除的结点 x 为红色，那么这个结点的父结点和子结点都一定是黑色，因此，只需要把子结点直接连向父结点就可以了，不会破坏红黑树的五条规则。如果删除的黑色节点，就需要把该结点下的子树的根结点变为双重黑 调整操作就是为了干掉双重黑 其中分兄弟黑和兄弟红，兄弟红可以转为兄弟黑情况，这里主要分兄弟黑的三种情况 黑兄弟的儿子全黑 x为双重黑 方案：黑上浮（当根结点为双重黑时，直接减一就行） RR或LL型LL黑兄弟是左孩子，黑兄弟的左孩子是只要是红色(不关心另一个孩子颜色) RR黑兄弟是右孩子，黑兄弟的右孩子是只要是红色(不关心另一个孩子颜色) 站在38大左旋， 调色：51调成38的颜色，38和72调成黑色 RL或LR型 先小右旋，交换51调黑72调红，变成了RR型 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define RED 0#define BLACK 1#define DBLACK 2typedef struct Node &#123; int key; int color; // 0 red, 1 black, 2 double black struct Node *lchild, *rchild;&#125; Node;Node __NIL;#define NIL (&amp;__NIL)__attribute__((constructor))void init_NIL() &#123; NIL-&gt;key = 0; NIL-&gt;lchild = NIL-&gt;rchild = NIL; NIL-&gt;color = BLACK; return ;&#125;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;lchild = p-&gt;rchild = NIL; p-&gt;color = RED; return p;&#125;bool has_red_child(Node *root) &#123; return root-&gt;lchild-&gt;color == 0 || root-&gt;rchild-&gt;color == 0;&#125;Node *left_rotate(Node *root) &#123; Node *temp = root-&gt;rchild; root-&gt;rchild = temp-&gt;lchild; temp-&gt;lchild = root; return temp;&#125;Node *right_rotate(Node *root) &#123; Node *temp = root-&gt;lchild; root-&gt;lchild = temp-&gt;rchild; temp-&gt;rchild = root; return temp;&#125;Node *insert_maintain(Node *root) &#123; if (!has_red_child(root)) return root; if (root-&gt;lchild-&gt;color == RED &amp;&amp; root-&gt;rchild-&gt;color == RED) &#123; root-&gt;color = RED; root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = BLACK; return root; &#125; if (root-&gt;lchild-&gt;color == RED) &#123; if (!has_red_child(root-&gt;lchild)) return root; if (root-&gt;lchild-&gt;rchild-&gt;color == RED) &#123; root-&gt;lchild = left_rotate(root-&gt;lchild); &#125; root = right_rotate(root); &#125; else &#123; if (!has_red_child(root-&gt;rchild)) return root; if (root-&gt;rchild-&gt;lchild-&gt;color == RED) &#123; root-&gt;rchild = right_rotate(root-&gt;rchild); &#125; root = left_rotate(root); &#125; root-&gt;color = RED; root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = BLACK; return root;&#125;Node *predeccessor(Node *root) &#123; Node *temp = root-&gt;lchild; while (temp-&gt;rchild != NIL) temp = temp-&gt;rchild; return temp;&#125;Node *erase_maintain(Node *root) &#123; if (root-&gt;lchild-&gt;color != DBLACK &amp;&amp; root-&gt;rchild-&gt;color != DBLACK) return root; if (has_red_child(root)) &#123; root-&gt;color = RED; if (root-&gt;lchild-&gt;color == RED) &#123; root = right_rotate(root); root-&gt;rchild = erase_maintain(root-&gt;rchild); &#125; else &#123; root = left_rotate(root); root-&gt;lchild = erase_maintain(root-&gt;lchild); &#125; root-&gt;color = BLACK; return root; &#125; if ((root-&gt;lchild-&gt;color == DBLACK &amp;&amp; !has_red_child(root-&gt;rchild)) || (root-&gt;rchild-&gt;color == DBLACK &amp;&amp; !has_red_child(root-&gt;lchild))) &#123; root-&gt;color += 1; root-&gt;lchild-&gt;color -= 1; root-&gt;rchild-&gt;color -= 1; return root; &#125; if (root-&gt;rchild-&gt;color == BLACK) &#123; if (root-&gt;rchild-&gt;rchild-&gt;color != RED) &#123; root-&gt;rchild-&gt;color = RED; root-&gt;rchild = right_rotate(root-&gt;rchild); root-&gt;rchild-&gt;color = BLACK; &#125; root-&gt;rchild-&gt;color = root-&gt;color; root-&gt;color = BLACK; root-&gt;lchild-&gt;color -= 1; root = left_rotate(root); root-&gt;rchild-&gt;color = BLACK; &#125; else &#123; if (root-&gt;lchild-&gt;lchild-&gt;color != RED) &#123; root-&gt;lchild-&gt;color = RED; root-&gt;lchild = left_rotate(root-&gt;lchild); root-&gt;lchild-&gt;color = BLACK; &#125; root-&gt;lchild-&gt;color = root-&gt;color; root-&gt;color = BLACK; root-&gt;rchild-&gt;color -= 1; root = right_rotate(root); root-&gt;lchild-&gt;color = BLACK; &#125; return root;&#125;Node *__erase(Node *root, int key) &#123; if (root == NIL) return root; if (root-&gt;key &gt; key) &#123; root-&gt;lchild = __erase(root-&gt;lchild, key); &#125; else if (root-&gt;key &lt; key) &#123; root-&gt;rchild = __erase(root-&gt;rchild, key); &#125; else &#123; if (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123; Node *temp = root-&gt;lchild == NIL ? root-&gt;rchild : root-&gt;lchild; temp-&gt;color += root-&gt;color; free(root); return temp; &#125; else &#123; Node *temp = predeccessor(root); root-&gt;key = temp-&gt;key; root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;key); &#125; &#125; return erase_maintain(root);&#125;Node *erase(Node *root, int key) &#123; root = __erase(root, key); root-&gt;color = BLACK; return root;&#125;Node *__insert(Node *root, int key) &#123; if (root == NIL) return getNewNode(key); if (root-&gt;key == key) return root; if (root-&gt;key &gt; key) &#123; root-&gt;lchild = __insert(root-&gt;lchild, key); &#125; else &#123; root-&gt;rchild = __insert(root-&gt;rchild, key); &#125; return insert_maintain(root);&#125;Node *insert(Node *root, int key) &#123; root = __insert(root, key); root-&gt;color = BLACK; return root;&#125;void clear(Node *root) &#123; if (root == NIL) return ; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return ;&#125;void output(Node *root) &#123; if (root == NIL) return ; printf(&quot;(%d | %d, %d, %d)\\n&quot;, root-&gt;color, root-&gt;key, root-&gt;lchild-&gt;key, root-&gt;rchild-&gt;key ); output(root-&gt;lchild); output(root-&gt;rchild); return ;&#125;int main() &#123; int op, val; Node *root = NIL; while (~scanf(&quot;%d%d&quot;, &amp;op, &amp;val)) &#123; switch (op) &#123; case 0: root = insert(root, val); break; case 1: root = erase(root, val); break; &#125; output(root); &#125; return 0;&#125; 并查集 解决连通性问题 MAKE—SET(x)：初始化操作：建立一个只包含x的元素，每个元素开始都是指向自己 FIND—SET(x) 查询操作：找到x所在的集合 UNION(x, y) 合并操作：将两棵树合并 不加优化的并查集，最坏情况森林会退化成链表，查询时间复杂度为O(N) Quick-Find 将所有连通的即属于同一集合的元素都染成代表元素的颜色，在树中就是都指向最终根结点，路径压缩就是这样子 1234567891011121314151617181920212223242526272829typedef struct UnionSet &#123; int *color; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;color = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for(int i = 1; i &lt;= n; i++) &#123; u-&gt;color[i] = i; &#125; return u;&#125;//查找int find(UnionSet *u, int x) &#123; return u-&gt;color[x];&#125;//合并int merge(UnionSet *u, int a, int b) &#123; if(find(u, a) == find(u, b)) return 0; int color_a = u-&gt;color[a]; for(int i = 1; i &lt;= u-&gt;n; i++) &#123; if(u-&gt;color[i] - color_a) continue; u-&gt;color[i] = u-&gt;color[b]; &#125; return 1;&#125; Quick-Union 解释：[x, y], 将x所在集合连通到y所在集合, x所在集合的代表为X，y所在集合的代表为Y，a[X] = Y 例：用Quick-Union算法求的下面十个点最终数组结果 画成树： 缺点：这样规定x做孩子连在y下面,极端情况下会退化成链表，优化看Weighted Quick-Union 12345678910111213141516171819202122232425262728typedef struct UnionSet &#123; int *father; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for(int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; &#125; return u;&#125;//查找int find(UnionSet *u, int x) &#123; if(u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;//合并int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if(fa == fb) return 0; u-&gt;father[fa] = fb; return 1;&#125; Weighted Quick-Union 这就是：按秩合并 解释：[x, y], 将x所在集合和y所在集合合并, 秩小的做孩子，秩大的做父亲 秩是按照节点数量比较还是树的高度比较呢？ ➟ 节点数量 通俗理解：像下面这种情况，就应该将树二接到树一下面，这样查询效率更高 公式推倒：$l_i$ 表示第$i$个点查询的次数，所有点查询总次数除以节点总数就是平均查找次数 可知应该根据节点数量将节点少的接在节点数量多得树下面 例：分别写出下面用Quick-Union和Weighted Quick-Union得到的数组最终结果 1234567891011121314151617181920212223242526272829303132333435#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet &#123; int *father, *size; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; if(u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if (fa == fb) return 0; if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); u-&gt;father[fb] = fa; u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125; Weighted Quick-Union With Path Compression 将所有点都指向它最终的根结点(它所在集合的代表元素)就是路径压缩，如上右图的0指向3 12345678910111213141516171819202122232425262728293031323334#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet &#123; int *father, *size; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; //u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; return u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if (fa == fb) return 0; //if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); u-&gt;father[fb] = fa; //u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125; 复杂度比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct DisjointSet&#123; int *father, *rank;&#125; DisjointSet;void init(DisjointSet *s, int size) &#123; s-&gt;father = (int *)malloc(sizeof(int) * size); s-&gt;rank = (int *)malloc(sizeof(int) * size); for (int i = 0; i &lt; size; ++i) &#123; s-&gt;father[i] = i; s-&gt;rank[i] = 1; &#125;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int find_set(DisjointSet *s, int node) &#123; if (s-&gt;father[node] != node) &#123; s-&gt;father[node] = find_set(s, s-&gt;father[node]); &#125; return s-&gt;father[node];&#125;int merge(DisjointSet *s, int node1, int node2) &#123; int ancestor1 = find_set(s, node1); int ancestor2 = find_set(s, node2); if (ancestor1 != ancestor2) &#123; if (s-&gt;rank[ancestor1] &gt; s-&gt;rank[ancestor2]) &#123; swap(&amp;ancestor1, &amp;ancestor2); &#125; s-&gt;father[ancestor1] = ancestor2; s-&gt;rank[ancestor2] = max(s-&gt;rank[ancestor2], s-&gt;rank[ancestor1] + 1); return 1; &#125; return 0;&#125;void clear(DisjointSet *s) &#123; free(s-&gt;father); free(s-&gt;rank); free(s);&#125;int main() &#123; DisjointSet *dsu = (DisjointSet *)malloc(sizeof(DisjointSet)); init(dsu, 100); int m, x, y; scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int ans = merge(dsu, x, y); if (ans) &#123; printf(&quot;success\\n&quot;); &#125; else &#123; printf(&quot;failed\\n&quot;); &#125; &#125; clear(dsu); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct DisjointSet &#123; int *father, *rank;&#125;DisjointSet;void init(DisjointSet *s, int size) &#123; s-&gt;father = (int *)malloc(sizeof(int) * size); s-&gt;rank = (int *)malloc(sizeof(int) * size); for (int i = 0; i &lt; size; ++i) &#123; s-&gt;father[i] = i; s-&gt;rank[i] = 1; &#125;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int find_set(DisjointSet *s, int node) &#123; return s-&gt;father[node];&#125;int merge(DisjointSet *s, int node1, int node2) &#123; int ancestor1 = find_set(s, node1); int ancestor2 = find_set(s, node2); if (ancestor1 != ancestor2) &#123; if (s-&gt;rank[ancestor1] &gt; s-&gt;rank[ancestor2]) &#123; swap(&amp;ancestor1, &amp;ancestor2); &#125; s-&gt;father[ancestor1] = ancestor2; s-&gt;rank[ancestor2] = max(s-&gt;rank[ancestor2], s-&gt;rank[ancestor1] + 1); //s-&gt;rank[ancestor2] += s-&gt;rank[ancestor1]; return 1; &#125; return 0;&#125;void clear(DisjointSet *s) &#123; free(s-&gt;father); free(s-&gt;rank); free(s);&#125;int main() &#123; int m, n; DisjointSet *s = (DisjointSet *)malloc(sizeof(DisjointSet)); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); init(s, m); int a, b; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); merge(s, a, b); &#125; for(int i = 0; i &lt; m; i++) &#123; printf(&quot;%d\\n&quot;, find_set(s, i)); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","slug":"1.hello-world","date":"2020-08-06T10:40:30.951Z","updated":"2020-08-13T00:36:49.056Z","comments":true,"path":"2020/08/06/1.hello-world/","link":"","permalink":"http://yoursite.com/2020/08/06/1.hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]}],"categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"},{"name":"算法学习","slug":"算法学习","permalink":"http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"最短路径算法","slug":"最短路径算法","permalink":"http://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}