{"meta":{"title":"现在做的一切都是在为未来打基础","subtitle":"","description":"","author":"Mr Lee.","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About me","date":"2020-07-31T00:27:29.000Z","updated":"2020-08-05T08:18:15.117Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"一名无名小卒 qq: 32849549879shouji: 123153465"},{"title":"分类","date":"2020-08-09T11:56:01.000Z","updated":"2020-08-11T13:11:24.638Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"留下你的想法~","date":"2020-08-11T13:12:28.000Z","updated":"2020-08-11T13:13:01.946Z","comments":true,"path":"messageboard/index.html","permalink":"http://yoursite.com/messageboard/index.html","excerpt":"","text":""},{"title":"那些年，我们听过的音乐","date":"2020-08-11T13:13:12.000Z","updated":"2020-08-11T13:13:37.887Z","comments":true,"path":"music/index.html","permalink":"http://yoursite.com/music/index.html","excerpt":"","text":""},{"title":"那些年，我们拍过的回忆","date":"2020-08-11T13:13:49.000Z","updated":"2020-08-11T13:14:14.929Z","comments":true,"path":"photos/index.html","permalink":"http://yoursite.com/photos/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-07-30T15:05:17.000Z","updated":"2020-08-05T08:18:02.051Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-08-06T12:43:11.401Z","updated":"2020-08-06T12:43:11.274Z","comments":true,"path":"tags/photos/index.css","permalink":"http://yoursite.com/tags/photos/index.css","excerpt":"","text":".test { width: 500px; height: 200px; background-color: red; } .iframe { } .audio { margin:auto; width: 350px; height: 90px; } .player-mid .mask { background: #fff; } .img-box1 { margin: auto; width: 80%; } .img1 { width: 100%; height: 350px; }"},{"title":"相册","date":"2020-08-09T11:53:16.560Z","updated":"2020-08-09T11:53:16.560Z","comments":true,"path":"tags/photos/index.html","permalink":"http://yoursite.com/tags/photos/index.html","excerpt":"","text":"那么爱他"}],"posts":[{"title":"关键字和右值","slug":"7.关键字和右值","date":"2020-08-12T02:56:36.145Z","updated":"2020-08-12T06:26:10.009Z","comments":true,"path":"2020/08/12/7.关键字和右值/","link":"","permalink":"http://yoursite.com/2020/08/12/7.%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%8F%B3%E5%80%BC/","excerpt":"","text":"关键字思考(c++11)autoauto 关键字在编译阶段自动进行类型推导 遍历容器时使用更方便 四种情况不能用: 不能用在函数参数 不能用在模板参数 不能定义数组 不能用于非静态成员变量 （其实我发现，只要变量不初始化就用不了） 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main() &#123; auto a = 123; cout &lt;&lt; sizeof(a) &lt;&lt; endl; map&lt;int, int&gt; arr; arr[44848798] = 798213; arr[12265] = 320; arr[65] = 33022; for (map&lt;int, int&gt;::iterator iter = arr.begin(); iter != arr.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; for (auto iter = arr.begin(); iter != arr.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; for (auto x : arr) &#123; //c++11新语法 cout &lt;&lt; x.first &lt;&lt; &quot; &quot; &lt;&lt; x.second &lt;&lt; endl; &#125; return 0;&#125; const作用在运行期 constexpr作用在编译期，在编译期就会确定表达式的具体值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;constexpr int f(int x) &#123; //c++11 constexpr不能修饰递归函数 return 3 * x * x + x;&#125;class A &#123; public: constexpr A(int x, int y) : x(x), y(y) &#123;&#125; int x, y;&#125;;int main() &#123; const int a = 123; cout &lt;&lt; a &lt;&lt; endl; int b; cin &gt;&gt; b; const int c = 2 * b; //const: 运行期状态, 这里发现编译的时候是不确定c的值的 int n; cin &gt;&gt; n; //constexpr int m = 2 * n; //constexpr 修饰:编译器常量 constexpr int m = 2 * 123; cout &lt;&lt; m &lt;&lt; endl; constexpr int x = f(12); constexpr A t(2, 3); //初始化一个编译器的常量对象, 把构造函数前加constexpr cout &lt;&lt; t.x &lt;&lt; &quot;, &quot; &lt;&lt; t.y &lt;&lt; endl; return 0;&#125; final 被final修饰的方法，子类不能进行重写 被final修饰的类，其他类不能进行继承 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A : public map&lt;int, int&gt; &#123; public: virtual void say() &#123; cout &lt;&lt; &quot;Claa A : hello world&quot; &lt;&lt; endl; &#125;&#125;;class B final : public A &#123; //加上final, 此类不能再被继承 public: void say() final override &#123; //加上final, 子类就不能在重写此方法 cout &lt;&lt; &quot;Class B : hell world&quot; &lt;&lt; endl; &#125;&#125;;/*class C : public B &#123; public: //void say() &#123; // cout &lt;, &quot;Class B : hell world&quot; &lt;&lt; endl; //&#125;&#125;;*/int main() &#123; A a; a[55] = 569; a[215] = 545; for (auto x : a) &#123; cout &lt;&lt; x.first &lt;&lt; &quot; &quot; &lt;&lt; x.second &lt;&lt; endl; &#125; cout &lt;&lt; endl; return 0;&#125; nullptrNULL 实际上是整型0，被强转了 (void*)0 而 nullptr本身就是一个地址，空的地址 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int f(int x) &#123; cout &lt;&lt; &quot;output in valu: &quot; &lt;&lt; x &lt;&lt; endl; return 0;&#125;int f(int *x) &#123; cout &lt;&lt; &quot;output address: &quot; &lt;&lt; x &lt;&lt; endl; return 0;&#125;int main() &#123; printf(&quot;%lld\\n&quot;, (long long)nullptr); cout &lt;&lt; sizeof(NULL) &lt;&lt; endl; int n = 123, *p = &amp;n; f(n); f(p); f(nullptr); f((int)NULL); return 0;&#125; 左值和右值最大的作用就是区分流程 左值和右值 光哥：同一的变量，单一的方式，访问到同样的结果就是左值，否则为右值 说白了就是，可以为这个表达式或表量赋值，那么它就是左值，否则就是右值 像一个中间产生的一个临时变量肯定给他赋不了值，它就是右值， 比如 a = 12 + 13 + 16 12 + 13会生成一个临时变量，它是右值 比如a++ ,想给 (a++) 赋值明显不能，那它就是右值 但是如果给(++a)赋值是可以的， 那 ++a就是一个左值 如何判断一个表达式是左值还是右值? ​ 定义一个传左值引用的函数，一个传右值引用的函数，倆函数同名，调用时将表达时传入，观察实际调用的是哪个函数来确定左右值 左值引用和右值引用&amp;就是左值引用， &amp;&amp;就是右值引用 左值会优先绑定在左值引用上， 右值会优先绑定在右值引用上 注意点： 如果形参是左值引用，实参传的是一个右值，要想编译通过，就在形参前加 const 一个形参是右值的函数，该参数在该函数内部实际上是一个左值 1234void f(int &amp;&amp;x) &#123; x += 1; return;&#125; 这里的 x虽然是一个右值引用，但它在该函数内，进行运算赋值是可以的，因此是一个左值，如果在函数里再调用另外两个函数（同样一个是右值引用的，一个传左值引用的，它会优先调用左值引用的。 这并不是想要的结果 因此**forward&lt;&gt;**帮我们解决的这一问题， 它会把变量转换为&lt;&gt;内的类型 因此可以在f函数内添加一句 forward&lt;int &amp;&amp;&gt;(x) 而 move 函数是将变量强制转换成一个 右值 move(x) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;#define TEST(a, f) &#123; \\ cout &lt;&lt; #a &lt;&lt; &quot; : &quot; &lt;&lt; #f &lt;&lt; &quot; &quot;; \\ f(a); \\&#125;void f2(int &amp;x) &#123; cout &lt;&lt; &quot;left value&quot; &lt;&lt; endl;&#125;void f2(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;right value&quot; &lt;&lt; endl;&#125;void f(int &amp;x) &#123; cout &lt;&lt; &quot;left value&quot; &lt;&lt; endl; TEST(x, f2);&#125;void f(int &amp;&amp;x) &#123; cout &lt;&lt; &quot;right value&quot; &lt;&lt; endl; //在f内部，这里x就是左值了，（可以放=左边） //TEST(x, f2); //这里就会按左值调用f2 TEST(forward&lt;int &amp;&amp;&gt;(x), f2); //向前传递 TEST(move(x), f2); //强制变成右值&#125;int test_func(const int &amp;&amp;x) &#123; //x += 1; cout &lt;&lt; x &lt;&lt; endl; return 0;&#125;int main() &#123; //表达式的返回结果可以放在等号左边则为左值 int a, b = 1, c = 3; (++a) = b + c; cout &lt;&lt; a &lt;&lt; endl; (a++); (a = b) = c; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; int arr[10]; arr[3] = 12; (a += 3) = 67; cout &lt;&lt; a &lt;&lt; endl; TEST(a += 3, f); TEST(1 + 4, f); TEST(b + c, f); TEST(a++, f); TEST(++a, f); test_func(123); test_func(move(a)); return 0;&#125; 移动构造函数在进行对象拷贝时， 我们之前都是调用的拷贝构造函数 如果对象成员中有连续存储空间（如一个数组），我们为了能进行真正的拷贝（即深拷贝），我们还需要显示的写出来拷贝构造函数，并在函数内实际地去申请相应的空间。 如果将一个临时的对象拷贝给另一个对象，我们则需要为新对象的成员开辟空间，并把临时对象的成员空间释放(析构时自动释放的)，这样很不划算，新开辟的空间和释放的空间存储的内容相同，这样我们就进行了一次看似多余的拷贝。其实有更好的办法，就是不为对象开辟新空间，而是直接把该对象的成员的指针指向这个临时对象的成员的那片存储区，再把临时对象成员指向nullptr ,这样就把临时对象中的占用的存储空间移到了新的对象这里。 谁来完成这一个操作呢，没错，就是移动构造函数，我们需要把移动构造函数写出来，他的形参是一个右值引用。 当进行对象拷贝时， 它就会被调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cstring&gt;using namespace std;namespace haizei &#123;class string &#123; public: string() &#123; cout &lt;&lt; &quot;default constructor&quot; &lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = 10; this-&gt;buff = new char[this-&gt;__buff_size]; this-&gt;__length = 0; &#125; string(const char *str) &#123; cout &lt;&lt; &quot;const char constructor: &quot;&lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = strlen(str) + 1; this-&gt;buff = new char[this-&gt;__buff_size]; strcpy(this-&gt;buff, str); this-&gt;__length = this-&gt;__buff_size - 1; &#125; string(const string &amp;s) &#123; //左值拷贝 cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; this &lt;&lt; endl; this-&gt;__buff_size = s.__buff_size; this-&gt;__length = s.__length; this-&gt;buff = new char[this-&gt;__buff_size]; strcpy(this-&gt;buff, s.buff); &#125; string(string &amp;&amp;s) &#123; //移动构造函数 //右值拷贝，将临时对象的存储区直接转交给当前对象，当前对象就不用再开辟空间复制内容了 cout &lt;&lt; &quot;move constructor: &quot; &lt;&lt; this &lt;&lt; &quot;, &quot; &lt;&lt; &amp;s &lt;&lt; endl; this-&gt;__buff_size = s.__buff_size; this-&gt;__length = s.__length; this-&gt;buff = s.buff; s.buff = nullptr; &#125; const char *c_str() const &#123; return buff; &#125; char &amp;operator[](int ind) &#123; return this-&gt;buff[ind]; &#125; string operator+(const string &amp;s) &#123; cout &lt;&lt; &quot;operator + &quot; &lt;&lt; this &lt;&lt; endl; int size = __length + s.__length + 1; char *temp = new char[size]; strcpy(temp, this-&gt;buff); strcat(temp, s.buff); return temp; //这里会调用有参构造函数 &#125; int size() &#123; return this-&gt;__length; &#125; char &amp;at(int ind) &#123; //at是需要判断边界的 if (ind &lt; 0 || ind &gt;= __length) &#123; cout &lt;&lt; &quot;String Error : out of range&quot; &lt;&lt; endl; return __end; &#125; return this-&gt;operator[](ind); &#125; ~string() &#123; cout &lt;&lt; &quot;destructor &quot; &lt;&lt; this &lt;&lt; endl; if (this-&gt;buff) delete this-&gt;buff; &#125; private: int __length, __buff_size; char *buff; char __end;&#125;;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, const haizei::string &amp;s) &#123; out &lt;&lt; s.c_str(); return out;&#125;int main() &#123; haizei::string s1 = &quot;hello world&quot;, s2 = &quot;, haizei&quot;, s3 = &quot;, harbin.&quot;; cout &lt;&lt; &quot;======s4 begin=====&quot; &lt;&lt; endl; haizei::string s4 = s1 + s2 + s3; cout &lt;&lt; &quot;======s4 end=======&quot; &lt;&lt; endl; haizei::string s5 = s4; cout &lt;&lt; s4 &lt;&lt; endl; cout &lt;&lt; s5 &lt;&lt; endl; s4[3] = &#x27;=&#x27;; cout &lt;&lt; s4 &lt;&lt; endl; cout &lt;&lt; s5 &lt;&lt; endl; cout &lt;&lt; s1 &lt;&lt; endl; s1[3] = &#x27;6&#x27;; cout &lt;&lt; s1 &lt;&lt; endl; cout &lt;&lt; s1 + s2 + s3 &lt;&lt; endl; for (int i = 0; i &lt; s1.size(); i++) &#123; cout &lt;&lt; s1[i] &lt;&lt; endl; &#125; return 0;&#125; g++ -fno-elide-constructors 选项可以使程序不进行返回值优化","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"多态","slug":"6.多态","date":"2020-08-09T11:45:35.612Z","updated":"2020-08-12T06:44:01.875Z","comments":true,"path":"2020/08/09/6.多态/","link":"","permalink":"http://yoursite.com/2020/08/09/6.%E5%A4%9A%E6%80%81/","excerpt":"虚函数","text":"虚函数 普通成员方法跟着类走， 虚函数跟着对象走 用父指针new出一个子对象，在没有虚函数的情况下，当父类指针调用同名方法时无法调用到子类的同名方法。 虽然new出来的是子类对象。 但调用普通方法时看的是前面的指针属于哪一个类就会调用哪一个类中的方法 而如果有虚函数，调用虚函数时，看的是new出来的对象具体是哪一个类，对象属于哪一个类，就调用哪一个类的方法。 这就是虚函数跟着对象走 虚函数声明 1virtual void func() &#123;&#125; 在方法前加virtual关键字 virtual 关键字不能修饰类方法(static) 纯虚函数 1virtual void func() = 0; 纯虚函数也叫接口方法 拥有纯虚函数的类叫抽象类(接口) 抽象类不能实例化 子类必须实现纯虚函数 补充 只要有继承，父类的析构函数就必须声明为 virtual 确保能正确析构子类的空间 原因：用父类的指针a去指向一个new出来子类对象。 如果父类析构函数没有声明为virtual, 那么析构函数就是普通成员方法（跟着类走），当delete a时， 它会执行父类中的析构函数，而不会执行子类中析构函数，那也就并没有析构掉子类的空间。 如果将父类析构函数声明为 virtual, 那么析构函数就会跟着对象走，new出来什么对象，就会执行哪个对象的析构函数 这样就会正确析构子类和父类 它可以方便进行类型转换 dynamic_cast override必须写 当子类重写父类方法时，务必要在方法名后面加上override，它能将运行期的错误变成编译期的错误 如果不写，一旦重写父类方法时把方法名字写错，那在编译期是看不到的 虚函数表在一个对象的存储空间中，最上面是一个8字节的虚函数表指针，他指向虚函数表，虚函数表存储所有虚函数的地址 一个类有一张虚函数表，他的所有对象的虚函数表指针都指向同一张虚函数表。 this指针说明: 实际上在成员方法中，第一个参数是 this指针，他是隐藏起来的 虚函数表的发现与验证当父类中没有虚函数时，输出子类对象的大小，发现和我们预期一致 当在父类中添加一个虚函数或多个虚函数时，发现子类对象的大小都会只增多8字节，猜测多了个函数指针，这就是虚函数表的地址 在外部定义一个函数指针，通过一个对象来找到虚函数表，并调用虚函数表中的方法，发现与猜测结果相同 this指针通过函数指针调用虚函数时，我们传一个参数，发现并不能正常调用虚函数了，这是因为虚函数第一个参数是一个隐藏的this指针，我们就显式的多传一个参数 第一个给他传一个对象的地址，发现调用的正是该对象的虚函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112class Animal &#123;public: virtual void run() &#123; cout &lt;&lt; &quot;I don&#x27;t know how to run&quot; &lt;&lt; endl; &#125;&#125;;class Cat : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can run with four legs&quot; &lt;&lt; endl; &#125;&#125;;class Dog : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can run with four legs, tail yao a yao!&quot; &lt;&lt; endl; &#125;&#125;;class Bat : public Animal &#123;public : void run() &#123; cout &lt;&lt; &quot;I can fly!&quot; &lt;&lt; endl; &#125;&#125;;class A &#123;public : A() = default; A(string s) &#123; cout &lt;&lt; &quot;param constructor&quot; &lt;&lt; endl; &#125; A(const A &amp;a) &#123; cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; &#125; int x; virtual void say(int xx) &#123; cout &lt;&lt; this &lt;&lt; endl; cout &lt;&lt; &quot;Class A : I can say, xx = &quot; &lt;&lt; xx &lt;&lt; &quot;, this-&gt;x = &quot;&lt;&lt; x &lt;&lt; endl; &#125;&#125;;typedef void (*func)(void *, int); //函数指针A retA() &#123; A temp_a(&quot;hello world&quot;); return temp_a;&#125;class Base &#123; public: Base() &#123; cout &lt;&lt; &quot;Base constructor&quot; &lt;&lt; endl; this-&gt;x = new int; &#125; virtual ~Base() &#123; cout &lt;&lt; &quot;Base destructor&quot; &lt;&lt; endl; delete this-&gt;x; &#125; private: int *x;&#125;;class Base_A: public Base &#123; public: Base_A() &#123; cout &lt;&lt; &quot;Base_A constructor&quot; &lt;&lt; endl; this-&gt;y = new int; &#125; ~Base_A() &#123; cout &lt;&lt; &quot;Base_A destructor&quot; &lt;&lt; endl; &#125; private: int *y;&#125;;int main() &#123; Base *ba = new Base_A(); delete ba; //普通的成员方法跟着类走，执行此句就不会调用Base_A的~Base_A(); //因此父类的析构函数一定得是虚函数 cout &lt;&lt; sizeof(A) &lt;&lt; endl; A temp_a, temp_b; temp_a.x = 9973; temp_b.x = 10000; temp_a.say(67); A temp_c = retA(); ((func **)(&amp;temp_a))[0][0](&amp;temp_b, 6); //用函数指针来调用虚函数表中的方法, 并且给虚函数say传参数 //虽然say中只有一个参数，但实际上，他还有一个隐藏的this, 第一个参数实际就是this, 隐藏了 //我们在这里通过函数指针来调用这个方法时，第一个方法就要传进去一个实际的对象地址 //他才会正确调用该对象的say方法 //这里虽然是通过temp_a对象找到的虚函数表中的say,但他并不会调用temp_a的say方法，他具体看的是第一个参数this指针是指向谁， //我们传进去temp_b的地址，他自然也就会调用temp_b的say方法, 并且把 6 作为复制给第二的参数 xx //我们在say中输出 this, 发现他确实也不是 temp_a 的地址 srand(time(0)); Cat a; Animal &amp;b = a; Animal *c[10]; cout &lt;&lt; sizeof(Cat) &lt;&lt; endl; for (int i = 0; i &lt; 10; i++) &#123; int op = rand() % 3; switch (op) &#123; case 0: c[i] = new Cat(); break; case 1: c[i] = new Dog(); break; case 2: c[i] = new Bat(); break; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; c[i]-&gt;run(); &#125; return 0;&#125; 运行结果： dynamic_cast这个类来做父类和子类的类型转换，当转换失败时就会返回NULL 父类对象地址能否转换成一个子类对象指针，对比的就是他们的虚函数表指针是否相同 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class A &#123; public: virtual ~A() &#123;&#125; private: &#125;;class B : public A &#123; public: void sayB() &#123; cout &lt;&lt; &quot;this is class B, x = &quot; &lt;&lt; x &lt;&lt; endl; &#125; int x;&#125;;class C : public A &#123; public: void sayC() &#123; cout &lt;&lt; &quot;this is class C, x =&quot; &lt;&lt; x &lt;&lt; endl; &#125; double x;&#125;;class D : public A &#123; public: void sayD() &#123; cout &lt;&lt; &quot;this is class D, x =&quot; &lt;&lt; x &lt;&lt; endl; &#125; string x;&#125;;int my_dynamic_cast(A *ta) &#123; char **pa = (char **)(ta); char **pb = (char **)(new B()); char **pc = (char **)(new C()); char **pd = (char **)(new D()); int ret = -1; if (pa[0] == pb[0]) ret = 0; else if (pa[0] == pc[0]) ret = 1; else if (pa[0] == pd[0]) ret = 2; return ret;&#125;int main() &#123; srand(time(0)); A *pa; B *pb; C *pc; D *pd; switch (rand() % 3) &#123; case 0: pb = new B(); pa = pb; pb-&gt;x = 254; break; case 1: pc = new C(); pa = pc; pc-&gt;x = 565.5; break; case 2: pd = new D(); pa = pd; pd-&gt;x = &quot;hell world&quot;; break; &#125; if ((pb = dynamic_cast&lt;B *&gt;(pa))) &#123; //转换失败返回NULL; cout &lt;&lt; &quot;class B :&quot;; pb-&gt;sayB(); &#125; else if ((pc = dynamic_cast&lt;C *&gt;(pa))) &#123; cout &lt;&lt; &quot;class C :&quot;; pc-&gt;sayC(); &#125; else if ((pd = dynamic_cast&lt;D *&gt;(pa))) &#123; cout &lt;&lt; &quot;class D :&quot;; pd-&gt;sayD(); &#125; switch (my_dynamic_cast(pa)) &#123; case 0: ((B *)(pa))-&gt;sayB(); break; case 1: ((C *)(pa))-&gt;sayC(); break; case 2: ((D *)(pa))-&gt;sayD(); break; &#125; return 0;&#125; 多态练习实现一个自定义哈希函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;namespace haizei &#123;class IHashFunc &#123; public: virtual int operator()(int) = 0;&#125;;class HashTable &#123; typedef int (*HashFunt_T)(int); typedef pair&lt;int, int&gt; PII; public: HashTable(HashFunt_T); HashTable(IHashFunc &amp;); int &amp;operator[](int); private: HashTable(HashFunt_T, IHashFunc *, int); int hash_type; HashFunt_T func1; IHashFunc *func2; int __size; PII **data;&#125;;HashTable::HashTable(HashFunt_T func1, IHashFunc *func2, int hash_type): func1(func1), func2(func2), hash_type(hash_type) &#123; this-&gt;__size = 1000; this-&gt;data = new PII*[this-&gt;__size]; for (int i = 0; i &lt; this-&gt;__size; i++) this-&gt;data[i] = nullptr;&#125;HashTable::HashTable(HashFunt_T func) : HashTable(func, nullptr, 1) &#123;&#125;HashTable::HashTable(IHashFunc &amp;func): HashTable(nullptr, &amp;func, 2) &#123;&#125;int &amp;HashTable::operator[](int x) &#123; int hash = 0; switch (hash_type) &#123; case 1: hash = func1(x); break; case 2: hash = (*func2)(x); break; &#125; if (hash &lt; 0) hash &amp;= 0x7fffffff; int ind = hash % __size, t = 1; while (data[ind] &amp;&amp; data[ind]-&gt;first != x) &#123; ind += t * t; if (ind &lt; 0) ind = ind &amp; 0x7fffffff; ind %= __size; t += 1; &#125; if (data[ind] == nullptr) data[ind] = new PII(x, 0); return data[ind]-&gt;second; &#125;&#125; //end of namespace haizeiint hash1(int x) &#123; return (x &lt;&lt; 1) ^ (x &lt;&lt; 3) ^ (x &gt;&gt; 5);&#125;class MyHashFunc : public haizei::IHashFunc &#123; public: int operator()(int x) override &#123; return (x &lt;&lt; 1) ^ (x &lt;&lt; 3) ^ (x &gt;&gt; 5); &#125;&#125;;int main() &#123; MyHashFunc hash2; haizei::HashTable h1(hash1); haizei::HashTable h2(hash2); h1[123] = 354; h2[123] = 345; cout &lt;&lt; h1[123] &lt;&lt; endl; cout &lt;&lt; h2[123] &lt;&lt; endl; cout &lt;&lt; h1[789] &lt;&lt; endl; cout &lt;&lt; h2[10000] &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"运算符重载","slug":"5.运算符重载","date":"2020-08-09T11:33:40.484Z","updated":"2020-08-12T06:48:52.193Z","comments":true,"path":"2020/08/09/5.运算符重载/","link":"","permalink":"http://yoursite.com/2020/08/09/5.%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/","excerpt":"简易cout、cin的实现","text":"简易cout、cin的实现 类内重载 12345678910111213141516171819202122232425262728293031323334353637//自己写一个命名空间namespace myspace &#123;class istream &#123;public: //返回对象的引用:为了一直使用这个cin对象，避免再拷贝一份 istream &amp;operator&gt;&gt;(int &amp;n) &#123; //参数传引用，避免再拷贝一份n std::cin &gt;&gt; n; //可以用scanf来实现 return *this; &#125;private:&#125;;class ostream &#123;public: ostream &amp;operator&lt;&lt;(int &amp;n) &#123; std::cout &lt;&lt; n; //可用printf(&quot;%g&quot;)来实现 return *this; &#125; ostream &amp;operator&lt;&lt;(const char *msg) &#123; std::cout &lt;&lt; msg; return *this; &#125;private:&#125;;istream cin;ostream cout;&#125;;int main() &#123; int n, m; myspace::cin &gt;&gt; n &gt;&gt; m; //系统默认为执行 cin.operator&gt;&gt;(n) myspace::cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot;\\n&quot;; return 0;&#125; 类外重载 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//自己写一个命名空间namespace myspace &#123;class istream &#123;public: //返回对象的引用:为了一直使用这个cin对象，避免再拷贝一份 istream &amp;operator&gt;&gt;(int &amp;n) &#123; //参数传引用，避免再拷贝一份n std::cin &gt;&gt; n; return *this; &#125;private:&#125;;class ostream &#123;public: ostream &amp;operator&lt;&lt;(int &amp;n) &#123; std::cout &lt;&lt; n; return *this; &#125; ostream &amp;operator&lt;&lt;(const char *msg) &#123; std::cout &lt;&lt; msg; return *this; &#125;private:&#125;;istream cin;ostream cout;&#125;;//类外重载运算符myspace::ostream &amp;operator&lt;&lt;(myspace::ostream &amp;out, double &amp;z) &#123; std::cout &lt;&lt; z; return out;&#125;ostream &amp;operator+(ostream &amp;out, const int &amp;a) &#123; //这时的a不仅可以是传过来的常量(子面量)也可以是变量 cout &lt;&lt; a; return out;&#125;int main() &#123; int n, m; //cin &gt;&gt; n: 系统会将其转化为 cin.oprator&gt;&gt;(n) myspace::cin &gt;&gt; n &gt;&gt; m; myspace::cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; m &lt;&lt; &quot;\\n&quot;; double k = 5.5; myspace::cout &lt;&lt; k &lt;&lt; &quot;\\n&quot;; (((((cout + 8) &lt;&lt; &quot; &quot;) + 9 )&lt;&lt; &quot; &quot;) + 10) &lt;&lt; &quot;\\n&quot;; //要注意 + 和 &lt;&lt; 的优先级 return 0;&#125; 重载实战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//重载运算符的方法的参数个数一定要和原来运算符的目数相同//优先匹配类内重载#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class Point &#123;public : Point() : __x(0), __y(0) &#123;&#125; Point(int x, int y) : __x(x), __y(y) &#123;&#125; int x() const &#123; return __x; &#125; int y() const &#123; return __y; &#125; Point operator+(const Point &amp;a) &#123; return Point(x() + a.x(), y() + a.y()); &#125; Point &amp;operator+=(const Point &amp;a) &#123; __x += a.x(); __y += a.y(); return *this; &#125; Point &amp;operator++() &#123; //前++ __x += 1; __y += 1; return *this; &#125; Point operator++(int) &#123; //后++ //返回不能是引用，因为方法一结束，temp就没了，所以要返回一个temp的拷贝 Point temp(*this); __x += 1; __y += 1; return temp; &#125;private: int __x, __y;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const Point &amp;a) &#123; out &lt;&lt; &quot;Point (&quot; &lt;&lt; a.x() &lt;&lt; &quot;, &quot; &lt;&lt; a.y() &lt;&lt; &quot;)&quot;; return out;&#125;int main() &#123; Point a(4, 5), b(3, 4), c(1, 1); cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; a + b &lt;&lt; endl; cout &lt;&lt; &quot;pre incr: &quot; &lt;&lt; ++(c += b) &lt;&lt; endl; //++(c += b); cout &lt;&lt; c &lt;&lt; endl; cout &lt;&lt; &quot;after incr: &quot; &lt;&lt; c++ &lt;&lt; endl; int n = 6, m = 7; (n += m)++; cout &lt;&lt; n &lt;&lt; endl; return 0;&#125; 特殊运算符的重载 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586class A &#123;public : A() &#123; arr = new int[10]; &#125; A(const A &amp;a) : A() &#123; //深拷贝，系统默认拷贝构造是浅拷贝() for (int i = 0; i &lt; 10; i++) &#123; this-&gt;arr[i] = a.arr[i]; &#125; this-&gt;x = a.x; this-&gt;y = a.y; &#125; int x, y; int *arr;&#125;;class B &#123;public: B() : obj(nullptr)&#123; arr = new int[10]; arr[3] = 9972; &#125; B(A *obj) : B() &#123; this-&gt;obj = obj; &#125; int operator()(int a, int b)&#123; return a + b; &#125; int &amp;operator[](int ind) &#123; //返回引用,返回的是ind处的变量 return arr[ind]; &#125; void operator[](const char *msg) &#123; cout &lt;&lt; msg &lt;&lt; endl; return ; &#125; A *operator-&gt;() &#123; return obj; &#125; A &amp;operator*() &#123; return *obj; &#125; ~B() &#123; delete arr; &#125;private: int *arr; A *obj;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const A &amp;a) &#123; out &lt;&lt; &quot;A(&quot; &lt;&lt; a.x &lt;&lt; &quot;, &quot; &lt;&lt; a.y &lt;&lt; &quot;)&quot;; return out;&#125;//主函数中是外部表现，类中是内部实现int main() &#123; B add; cout &lt;&lt; add(3, 5) &lt;&lt; endl; //函数对象(像函数的对象)，重载() add[3] = 787; //数组对象, 重载[] cout &lt;&lt; add[3] &lt;&lt; endl; add[&quot;hello world&quot;]; A a, b(a); //浅拷贝 a.x = 87, a.y = 852; B p = &amp;a; //指针对象 cout &lt;&lt; p-&gt;x &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;y &lt;&lt; endl; cout &lt;&lt; *p &lt;&lt; endl; a.arr[3] = 111; b.arr[3] = 222; cout &lt;&lt; a.arr[3] &lt;&lt; endl; cout &lt;&lt; b.arr[3] &lt;&lt; endl; cout &lt;&lt; sizeof(a) &lt;&lt; endl; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class IntArray &#123; public: IntArray(int n) : n(n) &#123; this-&gt;arr = new int[n]; &#125; IntArray(IntArray &amp;obj) : n(obj.n)&#123; this-&gt;arr = new int[n]; for (int i = 0; i &lt; n; i++) &#123; this-&gt;arr[i] = obj[i]; &#125; &#125; int &amp;operator[](int ind) &#123; if (ind &gt;= 0) &#123; return this-&gt;arr[ind]; &#125; else &#123; return this-&gt;arr[this-&gt;n + ind]; &#125; &#125; void operator+=(int num) &#123; for (int i = 0; i &lt; n; i++) &#123; this-&gt;arr[i] += num; &#125; return ; &#125; IntArray operator++(int x) &#123; //后++, 无论后++还是前++都是要加的。所以要提前拷贝一份返回加之前的样子. IntArray temp(*this); for (int i = 0; i &lt; this-&gt;n; i++) &#123; this-&gt;arr[i] += 1; &#125; return temp; &#125; IntArray &amp;operator++() &#123; for (int i = 0; i &lt; this-&gt;n; i++) &#123; this-&gt;arr[i] += 1; &#125; return *this; &#125; friend ostream &amp;operator&lt;&lt;(ostream &amp;, const IntArray &amp;); ~IntArray() &#123; delete[] this-&gt;arr; &#125; private: int *arr, n;&#125;;ostream &amp;operator&lt;&lt;(ostream &amp;out, const IntArray &amp;a) &#123; out &lt;&lt; &quot;[ &quot;; for (int i = 0; i &lt; a.n; i++) &#123; out &lt;&lt; a.arr[i] &lt;&lt; &quot; &quot;; &#125; out &lt;&lt; &quot;]&quot;; return out;&#125;int main() &#123; srand(time(0)); IntArray a(10); for (int i = 0; i &lt; 10; i++) &#123; a[i] = rand() % 100; //！！这里要注意一下如何重载[], a[i]返回值应该是arr[i]这个变量的引用 &#125; cout &lt;&lt; a &lt;&lt; endl; //输出数组中所有的元素 cout &lt;&lt; a[4] &lt;&lt; endl; cout &lt;&lt; a[-2] &lt;&lt; endl; //输出倒数第2位的值 a += 5; //给数组的所有元素都加5 cout &lt;&lt; a &lt;&lt; endl; //输出数组中所有的元素 cout &lt;&lt; (a++) &lt;&lt; endl; //给数组中所有元素都加1 cout &lt;&lt; (++a) &lt;&lt; endl; //给数组中所有元素都加1 return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"继承","slug":"4.继承","date":"2020-08-09T11:26:43.790Z","updated":"2020-08-12T07:23:21.811Z","comments":true,"path":"2020/08/09/4.继承/","link":"","permalink":"http://yoursite.com/2020/08/09/4.%E7%BB%A7%E6%89%BF/","excerpt":"继承","text":"继承 继承,父类中的所有属性都会包含进子类中子类在内存中的存储，前半部分是存储父类的信息，后半部分是存储的本身的属性。所以子类对象的地址可以看成一个父类对象的地址 继承-子类的访问权限 子类无论是public继承、protected继承 还是private继承，他都无法访问到父类中private中的东西。但是父类中的public、protected都可以访问 继承-对外的访问权限 ==继承权限影响的是外部对子类中的 继承自父类的 属性和方法的访问权限== ==这些权限只能缩小不能放大== 1234567891011121314151617181920212223242526272829303132333435363738......class Animal &#123; public: Animal(string name, int age) : __name(name), age(age) &#123;&#125; void say() &#123; cout &lt;&lt; &quot;my name is: &quot; &lt;&lt; __name &lt;&lt; &quot;my age is: &quot; &lt;&lt; age &lt;&lt; endl; &#125; protected: string __name; private: int age;&#125;;class Cat : public Animal &#123; public : Cat() = delete; Cat(string name, int age) : Animal(name, age) &#123;&#125;&#125;;class Bat : protected Animal &#123; public: Bat() = delete; Bat(string name, int age) : Animal(name, age) &#123;&#125; void say() &#123; //this-&gt;Animal::say(); Animal::say(); cout &lt;&lt; &quot;Bat name: &quot; &lt;&lt; __name &lt;&lt; endl; //cout &lt;&lt; &quot;Bat age: &quot; &lt;&lt; age &lt;&lt; endl; //访问不了 &#125;&#125;;int main() &#123; Cat a(&quot;kitty&quot;, 29); a.say(); Bat b(&quot;hug&quot;, 16384); b.say(); return 0;&#125; 菱形继承c++支持多继承，但容易出现菱形继承，尽量避免这种情况出现 继承中的构造函数如何工作子类的构造函数 ： Cat() : 初始化列表 &#123;构造逻辑&#125; 在初始化列表结束后，初始化其实就已经完成了初始化列表可以显式的调用父类的构造函数，也可以隐式的不写(自动调用父类的默认构造函数) 子类实例化一个对象： 1. 会先调用子类构造函数 Cat() 2. 执行初始化参数列表（这里会先调用父类的构造函数，其次初始化子类中的属性） 3. 父类构造结束，然后子类的构造在结束 4. 再执行子类构造函数中的{构造逻辑} ==因此说：父类先完成构造，子类后完成构造==注意！！：在初始化列表中初始化子类的属性时、书写属性的顺序与初始化的顺序无关而与属性在子类中的声明顺序有关 12345678910111213141516171819202122232425262728293031323334353637383940class D &#123; public: D() &#123; cout &lt;&lt; &quot;D constructor&quot; &lt;&lt; endl; &#125; ~D() &#123; cout &lt;&lt; &quot;D destructor&quot; &lt;&lt; endl; &#125;&#125;;class A &#123; public: A() = delete; A(int x, int y) &#123; cout &lt;&lt; &quot;A constructor&quot; &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;A destructor&quot; &lt;&lt; endl; &#125;&#125;;class B &#123; public: B() &#123; cout &lt;&lt; &quot;B constructor&quot; &lt;&lt; endl; &#125; ~B() &#123; cout &lt;&lt; &quot;B destructor&quot; &lt;&lt; endl; &#125;&#125;;class C : public D &#123; public: C() : a(3, 4), b() &#123; cout &lt;&lt; &quot;C constructor&quot; &lt;&lt; endl; &#125; //显示的写出来初始化列表 ~C() &#123; cout &lt;&lt; &quot;C destructor&quot; &lt;&lt; endl; &#125; private: B b; A a;&#125;;int main() &#123; C c; return 0;&#125; 继承中的拷贝构造函数在子类构造函数中如果要调用父类的拷贝构造函数，就需要在初始化列表中显式的写出来，否则会默认调用父类的默认构造函数子类在内存中的存储，前半部分是存储父类的信息，后半部分是存储的本身的属性。所以子类对象的地址可以看成一个父类对象的地址，子类的地址就可以赋给父类指针。 12345678910111213141516171819202122232425262728293031323334class A &#123; public: A() &#123; cout &lt;&lt; &quot;class A constructor&quot; &lt;&lt; endl; this-&gt;x = 0x01020304; &#125; A(const A &amp;a) &#123; cout &lt;&lt; &quot;class A copy constructor&quot; &lt;&lt; this &lt;&lt; endl; &#125; int x;&#125;;class B : public A &#123; public: B() &#123; this-&gt;y = 0x05060708; cout &lt;&lt; &quot;class B constructor&quot; &lt;&lt; endl; &#125; B(const B &amp;b) : A(b) &#123; //要显示的调用父类的构造，否则默认是调用默认构造 cout &lt;&lt; &quot;class B copy constructor&quot; &lt;&lt; this &lt;&lt; endl; &#125; int y;&#125;;int main() &#123; B b1; B b2(b1); const char *msg = (const char *)(&amp;b1); for (int i = 0; i &lt; sizeof(B); i++) &#123; printf(&quot;%X&quot;, msg[i]); &#125; cout &lt;&lt; endl; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"类与对象","slug":"3.类与对象","date":"2020-08-09T11:18:28.994Z","updated":"2020-08-12T07:11:45.163Z","comments":true,"path":"2020/08/09/3.类与对象/","link":"","permalink":"http://yoursite.com/2020/08/09/3.%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/","excerpt":"成员属性与方法","text":"成员属性与方法 每个对象都有自己的一份属性和方法 访问权限public ：公共访问属性。protected ： 私有访问属性。孩子们和自己可以访问属性，其他的不可以private：受保护的访问权限。friend ：是类外的一个函数，类中将一函数声明为friend，该函数就可以访问类中的成员 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;class People &#123; friend int main(); //友元函数 int x, y;public: void set(int x); void say();&#125;;struct People2 &#123; int x, y;&#125;;void People::set(int x) &#123; cout &lt;&lt; &quot;set function: &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = x; return ;&#125; void People::say() &#123; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; return ;&#125;int main() &#123; People a; People2 b; a.set(3); a.y = 18432; a.say(); cout &lt;&lt; &quot;a object: &quot; &lt;&lt; &amp;a &lt;&lt; endl; b.x = 4; cout &lt;&lt; b.x &lt;&lt; endl; return 0;&#125; 运行结果 特殊函数 默认构造函数系统默认存在没有参数的什么也不做的构造函数系统自动调用 有参构造函数自己写一个有参的构造函数，默认的就没了 转换构造函数有参构造函数但只有一个参数 拷贝构造函数同类型的对象复制默认拷贝：逐个将对象的每个成员变量拷贝给另一个对象（如果源对象中有个指针，默认拷贝的话，那就会把指针的值拷贝一份，那样这两对象中的指针就会指向同一个空间，就不会实现真正的拷贝，看代码） 123456789101112131415161718192021222324252627class A &#123; public: A() &#123; this-&gt;arr = new int[100]; &#125; int *arr; int x, y;&#125;;int main() &#123; A a1; a1.x = 3, a1.y = 4; A a2 = a1; cout &lt;&lt; &quot;a1.x:&quot; &lt;&lt; a1.x &lt;&lt; &quot; a1.y:&quot; &lt;&lt; a1.y &lt;&lt; endl; cout &lt;&lt; &quot;a2.x:&quot; &lt;&lt; a2.x &lt;&lt; &quot; a2.y:&quot; &lt;&lt; a2.y &lt;&lt; endl; cout &lt;&lt; endl; a1.x = 555; a2.x = 666; cout &lt;&lt; &quot;a1.x:&quot; &lt;&lt; a1.x &lt;&lt; &quot; a1.y:&quot; &lt;&lt; a1.y &lt;&lt; endl; cout &lt;&lt; &quot;a2.x:&quot; &lt;&lt; a2.x &lt;&lt; &quot; a2.y:&quot; &lt;&lt; a2.y &lt;&lt; endl; a1.arr[0] = 89; a2.arr[0] = 79988; cout &lt;&lt; &quot;a1.arr[0]:&quot; &lt;&lt; a1.arr[0] &lt;&lt; endl; cout &lt;&lt; &quot;a2.arr[0]:&quot; &lt;&lt; a2.arr[0] &lt;&lt; endl; return 0;&#125; 浅拷贝 系统的默认的拷贝,上面代码 深拷贝 为了解决默认拷贝构造的bug,就需要自己写一个拷贝构造函数,(在自己写的拷贝构造函数中重新开辟自己指针所指向的空间。）1234A(const A &amp;obj) : x(obj.x), y(obj.y) &#123; this-&gt;arr = new int[100]; memcpy(this-&gt;arr, obj.arr, sizeof(int) * 100);&#125; 复制赋值运算符析构函数函数结束系统自动调用，析构函数的调用顺序与构造函数的调用顺序正好相反因为后构造的可能会依赖到先构造的，如果先把先构造的给析构掉就可能出错 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;class People &#123;public : People() &#123; cout &lt;&lt; &quot;默认构造函数&quot; &lt;&lt; endl; &#125; //People() = default; //默认构造函数 People(string name) &#123; //有参构造函数（因为形参只有一个，也叫转换构造函数） cout &lt;&lt; &quot;param constructor&quot; &lt;&lt; endl; this-&gt;name = name; &#125; People(int x) &#123; //同上 cout &lt;&lt; &quot;int param constructor&quot; &lt;&lt; endl; this-&gt;x = x; &#125; People(const People &amp;a) &#123; //拷贝构造函数，这里的参数必须是引用 //否则，形参也会调用拷贝构造函数，会发生无限循环的调用 cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl; this-&gt;name = a.name; this-&gt;x = a.x; &#125; void operator=(const People &amp;a) &#123; //赋值运算符 cout &lt;&lt; &quot;operator =&quot; &lt;&lt; endl; this-&gt;name = a.name; this-&gt;x = a.x; return ; &#125; ~People() &#123; //析构函数 cout &lt;&lt; &quot;destructor&quot; &lt;&lt; endl; &#125; string name; int x;&#125;;void incr(int &amp;a) &#123; //引用小示例 a += 1; return ;&#125;int add(People a, People b) &#123; return a.x + b.x;&#125;int main() &#123; People f; //调用默认构造函数 int n = 7; incr(n); cout &lt;&lt; n &lt;&lt; endl; //4, 5会自动调用转换构造函数，先转换成People对象. add函数结束并调用两次析构函数 cout &lt;&lt; add(4, 5) &lt;&lt; endl; People a(&quot;hug&quot;); //调用(一个参数的)有参构造函数(转换构造函数) People b = string(&quot;hug&quot;); //同上 People c(543); //同上 People d = 678; //同上 cout &lt;&lt; a.name &lt;&lt; endl; cout &lt;&lt; b.name &lt;&lt; endl; cout &lt;&lt; c.x &lt;&lt; endl; cout &lt;&lt; d.x &lt;&lt; endl; //c = 987重点理解：987会先调用转换构造函数生成一个对象赋值给C, //赋值给C时注意！！这时候调用的不是转换构造函数也不是拷贝构造函数 //因为此时的C已不再是初次定义，因此它这次调用的是 赋值运算符函数！ //赋值给C之后，987生成的匿名对象会再调用析构函数。 c = 987; cout &lt;&lt; c.x &lt;&lt; endl; d = string(&quot;xiaoming&quot;); //调用有参构造函数(转换构造函数) cout &lt;&lt; d.name &lt;&lt; endl; People e = a; //调用拷贝构造函数 cout &lt;&lt; e.name &lt;&lt; endl; cout &lt;&lt; e.x &lt;&lt; endl; c = a; //c不是首次定义，此时调用赋值运算符函数 cout &lt;&lt; c.name &lt;&lt; endl; cout &lt;&lt; c.x &lt;&lt; endl; return 0;&#125; 运行结果 类属性与方法static 修饰所有对象共享一份 const方法不去修改任何成员属性的值const 限定符，它把一个对象转换成一个常量。 对象与引用 c++中的结构体与类C++中的struct实际是个类，里面的属性方法默认是public类中写个属性或方法默认是private 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;class Point &#123;public : Point() &#123; cout &lt;&lt; &quot;constructor : &quot; &lt;&lt; this &lt;&lt; endl; Point::total_cnt += 1; seek_cnt = 0; &#125; Point(const Point &amp;a) : Point() &#123; //拷贝构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;copy constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = a.x; this-&gt;y = a.y; &#125; Point(double z) : Point() &#123; //转换构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;convert constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = 99, this-&gt;y = 99; &#125; Point(int x, int y) : Point() &#123; //有参构造函数。会先调用默认构造函数 cout &lt;&lt; &quot;param constructor : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = x; this-&gt;y = y; &#125; void operator=(const Point &amp;a) &#123; //赋值运算符。会先调用默认构造函数 cout &lt;&lt; &quot;operator= : &quot; &lt;&lt; this &lt;&lt; endl; this-&gt;x = a.x, this-&gt;y = a.y; return ; &#125; void set(int x, int y) &#123; this-&gt;x = x, this-&gt;y = y; &#125; void seek() const &#123; seek_cnt += 1; cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl; &#125; int S() const &#123; return seek_cnt; &#125; static int T() &#123; return Point::total_cnt; &#125; //类方法，所有对象共享一个,访问方法Point:: ~Point() &#123; //析构函数 cout &lt;&lt; &quot;destructor : &quot; &lt;&lt; this &lt;&lt; endl; Point::total_cnt -= 1; &#125; private: int x, y; mutable int seek_cnt; //如果想在const函数中修改一变量，就在声明变量时前面加一个mutable static int total_cnt; //类属性，在类外初始化，所有对象共享一个&#125;;int Point::total_cnt = 0;void test() &#123; Point a; cout &lt;&lt; Point::T() &lt;&lt; endl; return ;&#125;int main() &#123; Point a; //调用默认构造函数, total_cnt++ cout &lt;&lt; a.T() &lt;&lt; endl; //调用类方法, total_cnt = 1 //在test函数中：先调用默认构造函数, total_cnt++ //再调用类方法 total_cnt = 2 test(); //函数结束调用析构函数析构掉test中的a, total_cnt--, total_cnt = 1 Point b; //调用默认构造函数, total_cnt++ cout &lt;&lt; b.T() &lt;&lt; endl; //调用类方法， total_cnt = 2; Point c(3, 4); //先调用默认构造函数 total_cnt++，再调用有参构造函数 cout &lt;&lt; c.T() &lt;&lt; endl; //total_cnt = 3 Point d(3.4); //先调用默认构造函数 total_cnt++, 再调用转换构造函数 cout &lt;&lt; d.T() &lt;&lt; endl; //total_cnt = 4 //重点理解：5.6（先会调用默认构造函数 total_cnt++）调用转换构造函数生成匿名对象 //再调用赋值运算符赋值给c //赋值结束，5.6生成的匿名对象调用析构函数 total_cnt-- c = 5.6; cout &lt;&lt; c.T() &lt;&lt; endl; //total_cnt = 4 cout &lt;&lt; &amp;a &lt;&lt; endl; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; &amp;c &lt;&lt; endl; cout &lt;&lt; &amp;d &lt;&lt; endl; d.seek(); c.seek(); const Point e(6, 7); //const类型的类不能修改，只能调用const修饰的方法 e.seek(); e.seek(); e.seek(); e.seek(); cout &lt;&lt; e.S() &lt;&lt; endl; return 0;&#125; 返回值优化最初是“hug”先生成一个对象，拷贝给temp_atemp_a再生成一个匿名对象拷贝给a 三五法则","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"}]},{"title":"数据结构","slug":"2.DataStructure","date":"2020-08-06T10:40:46.543Z","updated":"2020-08-12T06:53:51.577Z","comments":true,"path":"2020/08/06/2.DataStructure/","link":"","permalink":"http://yoursite.com/2020/08/06/2.DataStructure/","excerpt":"数据结构 = 结构定义 + 结构操作","text":"数据结构 = 结构定义 + 结构操作 顺序表插入删除扩容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Vector &#123; int *data; int size, length;&#125; Vector;Vector *init(int n) &#123; Vector *vec = (Vector *)malloc(sizeof(Vector)); vec-&gt;data = (int *)malloc(sizeof(int) * n); vec-&gt;size = n; vec-&gt;length = 0; return vec;&#125;//扩容(倍增思想)int expand(Vector *vec) &#123; //vec-&gt;size *= 2; //vec-&gt;data = (int *)realloc(vec-&gt;data, sizeof(int) * vec-&gt;size); //return 1; int extr_size = vec-&gt;size; int *p; while(extr_size) &#123; p = (int *)realloc(vec-&gt;data, sizeof(int) * (vec-&gt;size + extr_size)); if(p) break; extr_size /= 2; &#125; if(p == NULL) return 0; vec-&gt;data = p; vec-&gt;size += extr_size; return 1;&#125;int insert(Vector *vec, int ind, int val) &#123; if(vec == NULL) return 0; if(ind &lt; 0 || ind &gt; vec-&gt;length) return 0; if(vec-&gt;length == vec-&gt;size) &#123; if(!expand(vec)) &#123; //printf(&quot;扩容失败\\n&quot;); return 0; &#125; printf(&quot;expand succeddfully! szie = %d\\n&quot;, vec-&gt;size); &#125; for(int i = vec-&gt;length; i &gt; ind; i--) &#123; vec-&gt;data[i] = vec-&gt;data[i - 1]; &#125; vec-&gt;data[ind] = val; vec-&gt;length++; return 1;&#125;int erase(Vector *vec, int ind) &#123; if(vec == NULL) return 0; if(ind &lt; 0 || ind &gt;= vec-&gt;length) return 0; for(int i = ind + 1; i &lt; vec-&gt;length; i++) &#123; vec-&gt;data[i - 1] = vec-&gt;data[i]; &#125; vec-&gt;length--; return 1;&#125;void output(Vector *vec) &#123; printf(&quot;Vector(%d) = [&quot;, vec-&gt;length); for(int i = 0; i &lt; vec-&gt;length; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, vec-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;void clear(Vector *vec) &#123; if(vec == NULL) return ; free(vec-&gt;data); free(vec); return ;&#125;int main() &#123; //随机种子 srand(time(0)); #define max_op 20 Vector *vec = init(1); int op, ind, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; ind = rand() % (vec-&gt;length + 3) - 1; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2:&#123; printf(&quot;insert %d at %d to Vector = %d\\n&quot;, val, ind, insert(vec, ind, val)); &#125; break; case 3: &#123; printf(&quot;erase item at %d from Vector = %d\\n&quot;, ind, erase(vec, ind)); &#125; break; &#125; output(vec); printf(&quot;\\n&quot;); &#125; clear(vec); return 0;&#125; 链表创建，初始化，插入，删除，遍历输出，反转，清空 普通链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;time.h&gt;#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct ListNode &#123; int data; struct ListNode *next;&#125; ListNode;typedef struct List &#123; ListNode head; int length;&#125; List;ListNode *getNewNode (int val) &#123; ListNode *p = (ListNode *)malloc(sizeof(ListNode)); p-&gt;data = val; p-&gt;next = NULL; return p;&#125;List *getLinkList() &#123; List *l = (List*)malloc(sizeof(List)); l-&gt;head.next = NULL; l-&gt;length = 0; return l;&#125;int insert(List *l, int ind, int val) &#123; if(l == NULL) return 0; if(ind &lt; 0 || ind &gt; l-&gt;length) return 0; ListNode *p = &amp;(l-&gt;head), *node = getNewNode(val); while(ind--) p = p-&gt;next; node-&gt;next = p-&gt;next; p-&gt;next = node; l-&gt;length++; return 1;&#125;int erase(List *l, int ind) &#123; if(ind &lt; 0 || ind &gt;= l-&gt;length) return 0; if(l == NULL) return 0; ListNode *p = &amp;(l-&gt;head), *q; while(ind--) p = p-&gt;next; q = p-&gt;next; p-&gt;next = q-&gt;next; free(q); l-&gt;length--; return 1;&#125;//链表反转void reverse(List *l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next, *q; l-&gt;head.next = NULL; while(p) &#123; q = p-&gt;next; p-&gt;next = l-&gt;head.next; l-&gt;head.next = p; p = q; &#125; return ;&#125;void output(List *l) &#123; printf(&quot;List(%d) = [&quot;, l-&gt;length); for(ListNode *p = l-&gt;head.next; p; p = p-&gt;next) &#123; printf(&quot;%d-&gt;&quot;, p-&gt;data); &#125; printf(&quot;NULL]\\n&quot;); return ;&#125;void clear_ListNode(ListNode *node) &#123; if(node == NULL) return ; free(node); return ;&#125;void clear_List(List *l) &#123; if(l == NULL) return ; ListNode *p = l-&gt;head.next, *q; while(p) &#123; q = p-&gt;next; clear_ListNode(p); p = q; &#125; free(l); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 List *l = getLinkList(); int op, ind, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; ind = rand() % (l-&gt;length + 3) - 1; val = rand() % 100; switch(op) &#123; case 0: case 1: &#123; printf(&quot;insert %d at %d to List = %d\\n&quot;, val, ind, insert(l, ind, val)); &#125; break; case 2: &#123; printf(&quot;revere List:&quot;); reverse(l); output(l); &#125; break; case 3: &#123; printf(&quot;erase item at %d from List = %d\\n&quot;, ind, erase(l, ind)); &#125; break; &#125; output(l); printf(&quot;\\n&quot;); &#125; clear_List(l); return 0;&#125; 单向循环链表约瑟夫问题 定义一个遍历指针，初始指向 head，并让 head 指向空地址避免操作结束后变为野指针。 找到遍历指针往后数的第 n 次所指向的结点。 输出该结点的数据，更新遍历指针，然后删除该结点。 重复操作 2 直至只剩下最后一个结点。 输出最后一个结点并删除。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node&#123; int data; struct Node *next;&#125;Node, *LinkedList;LinkedList insert(LinkedList head, Node *node, int index) &#123; if (head == NULL) &#123; if (index != 0) &#123; return head; &#125; head = node; head-&gt;next = head; return head; &#125; if (index == 0) &#123; node-&gt;next = head-&gt;next; head-&gt;next = node; return head; &#125; Node *current_node = head-&gt;next; int count = 0; while (current_node != head &amp;&amp; count &lt; index - 1) &#123; current_node = current_node-&gt;next; count++; &#125; if (count == index - 1) &#123; node-&gt;next = current_node-&gt;next; current_node-&gt;next = node; &#125; if (node == head-&gt;next) &#123; head = node; &#125; return head;&#125;// 请在下面实现输出函数 output_josephusvoid output_josephus(LinkedList head, int m) &#123; Node *current_node = head; head = NULL; while(current_node-&gt;next != current_node) &#123; for(int i = 1; i &lt; m; i++) &#123; current_node = current_node-&gt;next; &#125; printf(&quot;%d &quot;, current_node-&gt;next-&gt;data); Node *delete_node = current_node-&gt;next; current_node-&gt;next = current_node-&gt;next-&gt;next; free(delete_node); &#125; printf(&quot;%d\\n&quot;, current_node-&gt;data); free(current_node);&#125;int main() &#123; LinkedList linkedlist = NULL; int n, m; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; Node *node = (Node *)malloc(sizeof(Node)); node-&gt;data = i; node-&gt;next = NULL; linkedlist = insert(linkedlist, node, i - 1); &#125; output_josephus(linkedlist, m); return 0;&#125; 双向链表双向循环链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node &#123; int data; struct Node *prior, *next;&#125; Node, *List;/*typedef struct List &#123; Node *head; int length;&#125; List;*/List insert(List head, Node *node) &#123; if(head == NULL) &#123; head = node; head-&gt;next = head; head-&gt;prior = head; return head; &#125; node-&gt;next = head-&gt;next; node-&gt;prior = head; head-&gt;next-&gt;prior = node; head-&gt;next = node; head = node; return head;&#125;void output(List head, int m) &#123; Node *p = head; int cnt = 0; while(p-&gt;data != m) &#123; p = p-&gt;next; &#125; //p = p-&gt;prior; Node *q = p; printf(&quot;%d&quot;, q-&gt;data); while(q-&gt;prior != p) &#123; q = q-&gt;prior; printf(&quot; %d&quot;, q-&gt;data); &#125; printf(&quot;\\n&quot;); return ;&#125;void clear(List l) &#123; Node *p = l-&gt;next, *q; while(p != l) &#123; q = p-&gt;next; free(p); p = q; &#125; free(l); return ;&#125;int main() &#123; List list = NULL; int n, m, a; scanf(&quot;%d&quot;, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d&quot;, &amp;a); Node *node = (Node *)malloc(sizeof(Node)); node-&gt;data = a; node-&gt;prior = NULL; node-&gt;next = NULL; list = insert(list, node); &#125; scanf(&quot;%d&quot;, &amp;m); output(list, m); clear(list); return 0;&#125; 链表环的问题 队列循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;typedef struct Queue &#123; int *data; int head, tail, size, count;&#125; Queue;Queue *init(int n) &#123; Queue *q = (Queue *)malloc(sizeof(Queue)); q-&gt;data = (int *)malloc(sizeof(int) * n); q-&gt;size = n, q-&gt;head = 0, q-&gt;tail = 0, q-&gt;count = 0; return q;&#125;int empty(Queue *q) &#123; return !q-&gt;count;&#125;int front(Queue *q) &#123; return q-&gt;data[q-&gt;head];&#125;int push(Queue *q, int val) &#123; if(q == NULL) return 0; if(q-&gt;count == q-&gt;size) return 0; q-&gt;data[q-&gt;tail++] = val; //q-&gt;tail = (q-&gt;tail + 1) % q-&gt;size; if(q-&gt;tail == q-&gt;size) q-&gt;tail -= q-&gt;size; q-&gt;count++; return 1;&#125;void output(Queue *q) &#123; printf(&quot;Queue(%d) = [&quot;, q-&gt;count); for(int i= q-&gt;head, j = 0; j &lt; q-&gt;count; j++) &#123; j &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, q-&gt;data[(i + j) % (q-&gt;size)]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int pop(Queue *q) &#123; if(q == NULL) return 0; if(empty(q)) return 0; q-&gt;head++; if(q-&gt;head == q-&gt;size) q-&gt;head -= q-&gt;size; q-&gt;count--; return 1;&#125;void clear(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 Queue *queue = init(max_op); int op, val; for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to Queue = %d\\n&quot;, val, push(queue, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from Queue = &quot;, front(queue)); printf(&quot;%d\\n&quot;, pop(queue)); &#125; break; &#125; output(queue); printf(&quot;\\n&quot;); &#125; return 0;&#125; 单调队列 栈普通栈1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;typedef struct Stack &#123; int *data; int top, size;&#125; Stack;Stack *init(int n) &#123; Stack *s = (Stack *)malloc(sizeof(Stack)); s-&gt;data = (int *)malloc(sizeof(int) * n); s-&gt;top = -1; s-&gt;size = n; return s;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int top(Stack *s) &#123; return s-&gt;data[s-&gt;top];&#125;int expand(Stack *s) &#123; int ext_size = s-&gt;size * 2; int *p; while(ext_size) &#123; p = (int *)realloc(s-&gt;data, sizeof(int) * (s-&gt;size + ext_size)); if(p) return 0; ext_size /= 2; &#125; if(p == NULL) return 0; s-&gt;data = p; s-&gt;size += ext_size; return 1;&#125;int push(Stack *s, int val) &#123; if(s == NULL) return 0; if(s-&gt;top + 1 == s-&gt;size)&#123; if(expand(s) == 0) return 0; &#125; s-&gt;data[++(s-&gt;top)] = val; return 1;&#125;int pop(Stack *s) &#123; if(s == NULL) return 0; if(empty(s)) return 0; s-&gt;top -= 1; return 1;&#125;void output(Stack *s) &#123; printf(&quot;Stack(%d) = [&quot;, s-&gt;top + 1); for(int i = 0; i &lt;= s-&gt;top; i++) &#123; i &amp;&amp; printf(&quot;, &quot;); printf(&quot;%d&quot;, s-&gt;data[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 int op, val; Stack *s = init(max_op); for(int i = 0; i &lt; max_op; i++) &#123; op = rand() % 4; val = rand() % 100; switch(op) &#123; case 0: case 1: case 2: &#123; printf(&quot;push %d to Stack = %d\\n&quot;, val, push(s, val)); &#125; break; case 3: &#123; printf(&quot;pop %d from Stack = &quot;, top(s)); printf(&quot;%d\\n&quot;, pop(s)); &#125; break; &#125; output(s); printf(&quot;\\n&quot;); &#125; clear(s); return 0;&#125; 表达式求值 使用两个栈分别存储数值和运算符。 读取表达式字符，数值存入数值栈，运算符和栈顶运算符比较优先级。 通过运算符优先级不同选择将它压入栈或取出数值栈中两个元素进行计算，计算结果入栈。 返回步骤 2，直至表达式全部读完。 弹出一个运算符和两个数值进行运算，计算结果存储数值栈。 当运算符栈不为空时，返回步骤 5，否则数值栈中剩余的最后一个元素就是表达式求值结果。 利用系统栈，即递归 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;#define max_n 100#include &lt;inttypes.h&gt;int calc(const char *str, int l, int r) &#123; int prior = 0x3f3f3f3f - 1, temp = 0, pos = -1; for(int i = l; i &lt;= r; i++) &#123; int cur_prior = 0x3f3f3f3f; switch(str[i]) &#123; case &#x27;(&#x27; : temp += 100; break; case &#x27;)&#x27; : temp -= 100; break; case &#x27;+&#x27; : case &#x27;-&#x27; : cur_prior = temp + 1; break; case &#x27;*&#x27; : case &#x27;/&#x27; : cur_prior = temp + 2; break; case &#x27;^&#x27; : cur_prior = temp + 3; break; &#125; if(cur_prior &lt;= prior) &#123; pos = i; prior = cur_prior; &#125; &#125; if(pos == -1) &#123; int num = 0; for(int i = l; i &lt;= r; i++) &#123; if(str[i] &lt; &#x27;0&#x27; || str[i] &gt; &#x27;9&#x27;) continue; num = num * 10 + str[i] - &#x27;0&#x27;; &#125; return num; &#125; int a = calc(str, l, pos - 1); int b = calc(str, pos + 1, r); switch (str[pos]) &#123; case &#x27;+&#x27;: return a + b; case &#x27;-&#x27;: return a - b; case &#x27;*&#x27;: return a * b; case &#x27;/&#x27;: return a / b; case &#x27;^&#x27;: return (int)pow(a, b); &#125; return 0;&#125;int main() &#123; char str[max_n + 5] = &#123;0&#125;; while(scanf(&quot;%[^\\n]s&quot;, str) != EOF) &#123; getchar(); printf(&quot;%d\\n&quot;, calc(str, 0, strlen(str) - 1)); &#125; return 0;&#125; 单调栈 树二叉树性质： 二叉树遍历 递归的输出 1234567891011121314151617181920212223//前序遍历void pre_order(pNode p) &#123; if(p == NULL) return ; printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;l) pre_order(p-&gt;l); if(p-&gt;r) pre_order(p-&gt;r); return ;&#125;//中序遍历void in_order(pNode p) &#123; if(p == NULL) return ; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r); return ;&#125;//后序遍历void post_order(pNode p) &#123; if(p-&gt;l) post_order(p-&gt;l); if(p-&gt;r) post_order(p-&gt;r); printf(&quot;%c &quot;, p-&gt;data); return ;&#125; 二叉树的层次遍历孩子入队后爹出对 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/**********************************************将广义表转成二叉树再以层次遍历输出**********************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node &#123; char data; struct Node *l, *r;&#125; Node, *pNode;typedef struct Stack &#123; pNode *data; int top, size;&#125; Stack;typedef struct Queue &#123; pNode *data; int head, tail, size, cnt;&#125; Queue;//栈的操作void init_stack(Stack *s, int len) &#123; s-&gt;data = (pNode *)malloc(sizeof(pNode) * len); //??????????????????????????????????????????????????? s-&gt;top = -1; s-&gt;size = len; return ;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;int push(Stack *s, pNode p) &#123; if(s-&gt;top + 1 &gt;= s-&gt;size) &#123; return 0; &#125; s-&gt;data[++(s-&gt;top)] = p; return 1;&#125;pNode top(Stack *s) &#123; if(empty(s)) return NULL; return s-&gt;data[s-&gt;top];&#125;int pop(Stack *s)&#123; if(empty(s)) return 0; s-&gt;top--; return 1;&#125;void clear(Stack *s) &#123; if(s == NULL) return ; free(s-&gt;data); free(s); return ;&#125;//队列操作void init_queue(Queue *q, int len) &#123; q-&gt;data = (pNode*)malloc(sizeof(pNode) * (2 * len)); q-&gt;size = len; q-&gt;head = 0; q-&gt;tail = -1; q-&gt;cnt = 0; return ;&#125;int empty_queue(Queue *q) &#123; return q-&gt;tail &lt; q-&gt; head; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;int push_queue(Queue *q, pNode p) &#123; if(q-&gt;tail &gt;= q-&gt;size) return 0; q-&gt;data[++(q-&gt;tail)] = p; //xxxxxxxxxxxxxxxxxxxxxxxxtailduojialexxxxxxxxxxxxxxxxxxx q-&gt;cnt++; return 1;&#125;int pop_queue(Queue *q) &#123; if(empty_queue(q)) return 0; q-&gt;head++; return 1;&#125;void clear_queue(Queue *q) &#123; if(q == NULL) return ; free(q-&gt;data); free(q); return ;&#125;//树的操作Node *get_node(char c) &#123; Node *node = (Node *)malloc(sizeof(Node)); //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx node-&gt;data = c; node-&gt;l = node-&gt;r = NULL; return node;&#125;void clear_node(Node *node) &#123; if(node == NULL) return ; if(node-&gt;l) clear_node(node-&gt;l); if(node-&gt;r) clear_node(node-&gt;r); free(node); return ;&#125;pNode built_tree(char *str, int *node_num) &#123; pNode temp = NULL, current_root = NULL; Stack *s = (Stack *)malloc(sizeof(Stack)); //? init_stack(s, strlen(str)); int flag = 0; while(str[0]) &#123; switch(str[0]) &#123; case &#x27;(&#x27;: push(s, temp); flag = 0; temp = NULL; break; case &#x27;,&#x27;: flag = 1; temp = NULL; break; case &#x27;)&#x27;: current_root = top(s); pop(s); break; case &#x27; &#x27;: break; default: temp = get_node(str[0]); if(!empty(s) &amp;&amp; flag == 0) &#123; s-&gt;data[s-&gt;top]-&gt;l = temp; //xxxxxxxxxxxxxx &#125; else if(!empty(s) &amp;&amp; flag == 1)&#123; s-&gt;data[s-&gt;top]-&gt;r = temp; //xxxxxxxxxxxx top(s)-&gt;r=.. 不对 xxxxxxxxxxxxxxx &#125; ++(*node_num); break; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxx &#125; str++; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx忘写，导致我关机两次 &#125; if(temp &amp;&amp; !current_root) current_root = temp; //xxxx*** clear(s); //忘写 return current_root;&#125;//✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍ 层次遍历输出 ✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍✍void output(pNode node, int node_num) &#123; if(node_num == 0) return ; printf(&quot;%c&quot;, node-&gt;data); Queue *q = (Queue *)malloc(sizeof(Queue)); init_queue(q, node_num); push_queue(q, node); while(!empty_queue(q)) &#123; if(q-&gt;data[q-&gt;head]-&gt;l == NULL &amp;&amp; q-&gt;data[q-&gt;head]-&gt;r == NULL) &#123; pop_queue(q); continue; &#125; if(q-&gt;data[q-&gt;head]-&gt;l) &#123; push_queue(q, q-&gt;data[q-&gt;head]-&gt;l); printf(&quot; %c&quot;, q-&gt;data[q-&gt;head]-&gt;l-&gt;data); &#125; if(q-&gt;data[q-&gt;head]-&gt;r) &#123; push_queue(q, q-&gt;data[q-&gt;head]-&gt;r); printf(&quot; %c&quot;, q-&gt;data[q-&gt;head]-&gt;r-&gt;data); &#125; pop_queue(q); &#125; printf(&quot;\\n&quot;); clear_queue(q); return ;&#125;void in_order(pNode p) &#123; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c&quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r);&#125;int main()&#123; char str[100]; scanf(&quot;%[^\\n]s&quot;, str); int node_num = 0; pNode tree = built_tree(str, &amp;node_num); output(tree, node_num); clear_node(tree); return 0;&#125; 二叉树加线索化后孩子若为空就让右孩子指针域指向其后继 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define NORMAL 0#define THREAD 1typedef struct Node &#123; int data; struct Node *lchild, *rchild; int ltag, rtag;&#125; Node;Node *getNewNode(int val) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;data = val; p-&gt;lchild = p-&gt;rchild = NULL; p-&gt;ltag = NORMAL; p-&gt;rtag = NORMAL; return p;&#125;Node *insert(Node *root, int val) &#123; if (root == NULL) return getNewNode(val); if (root-&gt;data == val) return root; if (val &lt; root-&gt;data) root-&gt;lchild = insert(root-&gt;lchild, val); else root-&gt;rchild = insert(root-&gt;rchild, val); return root;&#125;void build_thread(Node *root) &#123; if (root == NULL) return ; static Node *pre = NULL; build_thread(root-&gt;lchild); if (root-&gt;lchild == NULL) &#123; root-&gt;lchild = pre; root-&gt;ltag = THREAD; &#125; if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) &#123; pre-&gt;rchild = root; pre-&gt;rtag = THREAD; &#125; pre = root; build_thread(root-&gt;rchild); return ;&#125;Node *most_left(Node *p) &#123; while (p &amp;&amp; p-&gt;ltag == NORMAL &amp;&amp; p-&gt;lchild != NULL) p = p-&gt;lchild; return p;&#125;void output(Node *root) &#123; Node *p = most_left(root); while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); if (p-&gt;rtag == THREAD) &#123; p = p-&gt;rchild; &#125; else &#123; p = most_left(p-&gt;rchild); &#125; &#125; return ;&#125;void in_order(Node *root) &#123; if (root == NULL) return ; if (root-&gt;ltag == NORMAL) in_order(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;data); if (root-&gt;rtag == NORMAL) in_order(root-&gt;rchild); return ;&#125;void clear(Node *root) &#123; if (root == NULL) return ; if (root-&gt;ltag == NORMAL) clear(root-&gt;lchild); if (root-&gt;rtag == NORMAL) clear(root-&gt;rchild); free(root); return ;&#125;int main() &#123; srand(time(0)); #define max_op 20 Node *root = NULL; for (int i = 0; i &lt; max_op; i++) &#123; int val = rand() % 100; root = insert(root, val); &#125; build_thread(root); output(root), printf(&quot;\\n&quot;); in_order(root), printf(&quot;\\n&quot;); clear(root); return 0;&#125; 广义表和二叉树1.由广义表创建二叉树 借助栈，栈里元素存节点的地址 1234567891011121314151617181920212223242526272829设置一个标记变量 flag，初始为 0；设置一个标记节点 temp,当前层父节current_root(即栈顶元素，每次出栈时赋值给current_root)循环遍历存储广义表的字符串 str：如果 str[i] 是 &#x27;(&#x27;： (遇到&#x27;(&#x27;此时的p才能当爹，因为&#x27;(&#x27;后面就开始是他的孩子了，这时让他进栈) 则设置 flag 为 0；(因为&#x27;(&#x27;后面第一个是他左孩子，要用flag == 0来识别) 把 temp 压入栈中。 temp = NULL;否则如果 str[i] &#x27;,&#x27;： 则设置flag为 1; (因为&#x27;，&#x27;后面一个是他右孩子，要用flag == 1来识别) temp = NULL;否则如果 str[i] 是 &#x27;)&#x27;： 则栈顶元素出栈;(当前栈顶元素出栈) current_root = top(s); pop(s);否则如果 str[i] 是 &#x27; &#x27;：break;否则如果 str[i] 是一个字母: 用节点 temp 来存储： 如果 flag 为 0： 将 temp 作为栈顶节点的左孩子； 如果 k 为 1： 将 temp 作为栈顶节点的右孩子； (另外可以用一个传出参数来记录节点个数) 最后要判断栈是否为空，若为空说明没遇到&#x27;(&#x27;,则只有一个根结点，直接把temp赋值给current_root 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct Node&#123; char data; struct Node *l, *r;&#125;Node, *pNode;typedef struct Stack&#123; pNode *data; int top, size;&#125; Stack;void init_stack(Stack *s, int len) &#123; s-&gt;data = (pNode *)malloc(sizeof(pNode) * len); s-&gt;size = len; s-&gt;top = -1; return ;&#125;int push(Stack *s, pNode p) &#123; if(s-&gt;top + 1 &gt;= s-&gt;size) return 0; s-&gt;data[++(s-&gt;top)] = p; return 1;&#125;int empty(Stack *s) &#123; return s-&gt;top == -1;&#125;pNode top(Stack *s) &#123; if(empty(s)) return NULL; return s-&gt;data[s-&gt;top];&#125;int pop(Stack *s) &#123; if(empty(s)) return 0; s-&gt;top -= 1; return 1;&#125;void clear_stack(Stack *s)&#123; if(s == NULL) return; free(s-&gt;data); free(s); return ;&#125;Node* get_node(char c) &#123; Node* p = (pNode)malloc(sizeof(Node)); p-&gt;data = c; p-&gt;l = p-&gt;r = NULL; return p;&#125;void clear_node (Node *node) &#123; if(node == NULL) return ; if(node-&gt;l) clear_node(node-&gt;l); if(node-&gt;r) clear_node(node-&gt;r); free(node); return ;&#125;pNode build(char *str, int *tree_node_num) &#123; pNode temp = NULL, current_root = NULL; Stack *s = (Stack *)malloc(sizeof(Stack)); init_stack(s, strlen(str)); int flag = 0; while(str[0]) &#123; switch (str[0]) &#123; case &#x27;(&#x27; : flag = 0; push(s, temp); temp = NULL; break; case &#x27;,&#x27; : flag = 1; temp = NULL; break; case &#x27;)&#x27; : current_root = top(s); pop(s); break; case &#x27; &#x27;: break; default : temp = get_node(str[0]); if(!empty(s) &amp;&amp; flag == 0) &#123; s-&gt;data[s-&gt;top]-&gt;l = temp; &#125; else if(!empty(s) &amp;&amp; flag == 1) &#123; s-&gt;data[s-&gt;top]-&gt;r = temp; &#125; ++(*tree_node_num); break; &#125; str++; &#125; if(temp &amp;&amp; !current_root) current_root = temp; //一个根结点 clear_stack(s); return current_root;&#125;void pre_order(pNode p) &#123; if(p == NULL) return ; printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;l) pre_order(p-&gt;l); if(p-&gt;r) pre_order(p-&gt;r); return ;&#125;void in_order(pNode p) &#123; if(p == NULL) return ; if(p-&gt;l) in_order(p-&gt;l); printf(&quot;%c &quot;, p-&gt;data); if(p-&gt;r) in_order(p-&gt;r); return ;&#125;void post_order(pNode p) &#123; if(p-&gt;l) post_order(p-&gt;l); if(p-&gt;r) post_order(p-&gt;r); printf(&quot;%c &quot;, p-&gt;data); return ;&#125;int main() &#123; char str[35] = &#123;0&#125;, c; scanf(&quot;%[^\\n]s&quot;, str); int tree_node_num = 0; pNode tree = build(str, &amp;(tree_node_num)); printf(&quot;前序:&quot;); pre_order(tree); printf(&quot;\\n&quot;); printf(&quot;中序:&quot;); in_order(tree); printf(&quot;\\n&quot;); printf(&quot;后序:&quot;); post_order(tree); printf(&quot;\\n&quot;); return 0;&#125; 2.二叉树生成广义表 输出节点存储的值； 如果左孩子不为空： 输出 &quot;(&quot;； 递归输出左子树； 如果右孩子为空： 输出 &quot;)&quot;。 如果右孩子不为空： 如果左孩子为空： 输出 &quot;(&quot;。 输出 “,”； 递归输出右子树； 输出 &quot;)&quot;。 1234567891011121314151617void output(Node *p) &#123; if(p == NULL) return ; printf(&quot;%c&quot;, p-&gt;data); if(p-&gt;l == NULL &amp;&amp; p-&gt;r == NULL) &#123; return ; &#125; printf(&quot;(&quot;); if(p-&gt;l) &#123; output(p-&gt;l); &#125; if(p-&gt;r) &#123; printf(&quot;,&quot;); output(p-&gt;r); &#125; printf(&quot;)&quot;); return ; &#125; 堆和优先队列概述 插入操作： 把新元素保存在数组的最后。 找到新插入元素的父节点位置。 将新元素与父节点比较大小。 若新插入的元素与其父节点大小不符合堆序性则交换它和父节点的位置，并回到步骤 2；若符合则插入操作完成。 删除操作： 将堆顶元素和最后一个元素交换。 删除堆的最后一个元素。 自顶向下调整元素的位置，使之满足堆序性。 堆排序：(将大根堆有小到大排序为例：) 将变量 i 设为堆末下标。 交换堆顶和第 i 个元素。 自上到下调整堆顶到第 i 个元素之间的堆结构，使之保持堆序性。 将 i 前移一位，重复步骤 2，直至 i 等于 1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//计蒜客写法#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Heap &#123; int *data, size;&#125; Heap;void init(Heap *h, int length_input) &#123; h-&gt;data = (int *)malloc(sizeof(int) * length_input); h-&gt;size = 0;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;void push(Heap *h, int value) &#123; h-&gt;data[h-&gt;size] = value; int current = h-&gt;size; int father = (current - 1) / 2; while (h-&gt;data[current] &gt; h-&gt;data[father]) &#123; swap(&amp;h-&gt;data[current], &amp;h-&gt;data[father]); current = father; father = (current - 1) / 2; &#125; h-&gt;size++;&#125;void output(Heap *h) &#123; for (int i = 0; i &lt; h-&gt;size; i++) &#123; printf(&quot;%d &quot;, h-&gt;data[i]); &#125; printf(&quot;\\n&quot;);&#125;int top(Heap *h) &#123; return h-&gt;data[0];&#125;void update(Heap *h, int pos, int n) &#123; int lchild = 2 * pos + 1, rchild = 2 * pos + 2; int max_value = pos; if (lchild &lt; n &amp;&amp; h-&gt;data[lchild] &gt; h-&gt;data[max_value]) &#123; max_value = lchild; &#125; if (rchild &lt; n &amp;&amp; h-&gt;data[rchild] &gt; h-&gt;data[max_value]) &#123; max_value = rchild; &#125; if (max_value != pos) &#123; swap(&amp;h-&gt;data[pos], &amp;h-&gt;data[max_value]); update(h, max_value, n); &#125;&#125;void pop(Heap *h) &#123; swap(&amp;h-&gt;data[0], &amp;h-&gt;data[h-&gt;size - 1]); h-&gt;size--; update(h, 0, h-&gt;size);&#125;// 请在下面实现堆排序函数 heap_sortvoid heap_sort(Heap *h) &#123; for(int i = h-&gt;size - 1; i &gt;= 1; i--) &#123; swap(&amp;h-&gt;data[i], &amp;h-&gt;data[0]); update(h, 0, i); &#125;&#125;void clear(Heap *h) &#123; free(h-&gt;data); free(h);&#125;int main() &#123; int arr[10] = &#123; 12, 9, 30, 24, 30, 4, 55, 64, 22, 37 &#125;; Heap *heap = (Heap *)malloc(sizeof(Heap)); init(heap, 100); for (int i = 0; i &lt; 10; i++) &#123; push(heap, arr[i]); &#125; output(heap); printf(&quot;%d\\n&quot;, top(heap)); pop(heap); output(heap); heap_sort(heap); output(heap); clear(heap); return 0;&#125; 线性建堆-堆排序 上面入堆操作是从下向上，每次进来一个放堆尾，再去维护，维护时反复跟父节点比较，Olog(n) 初始化建堆： 其实可以直接把所有元素先放数组里再一起去建堆，这时采用上面删除元素时自上而下的操作，从第n/2个元素到第一个元素每个元素(即非叶子节点)进行自上而下操作(下虑)，即反复让其与两个子节点比较直到不满足条件，所有点操作完就建好了一个堆O(n) 维护堆(重建堆)： 堆排序和建堆相同的操作，只不过这次是去维护堆，每次将堆顶元素(最值元素)跟倒数第i位交换堆就破环了再去将堆顶元素自上而下下虑维护堆，依次将所有堆顶元素放到后面就完成了排序nlog(n) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;void updata(int *arr, int ind, int n) &#123; //int temp = ind; //xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx写循环内 while((ind &lt;&lt; 1) &lt;= n) &#123; //xxxxxxxxxxxxxxxxxxxxxx int temp = ind, l = ind * 2, r = ind * 2 + 1; if(arr[l] &gt; arr[temp]) &#123; temp = l; &#125; if(r &lt;= n &amp;&amp; arr[r] &gt; arr[temp]) &#123; //xxxxxxxx temp = r; &#125; if(temp == ind) break; //xxxxxxxxxxxxxxxxxxxxxxx漏写 swap(arr[ind], arr[temp]); ind = temp; &#125;&#125;void heap_sort(int *arr, int n) &#123; arr -= 1; //初建堆 for(int i = n &gt;&gt; 1; i &gt;= 1; i--) &#123; updata(arr, i, n); &#125; //排序重建堆 for(int i = n; i &gt; 1; i--) &#123; swap(arr[i], arr[1]); updata(arr, 1, i - 1); &#125; return ;&#125;void output(int *arr, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); int n, val; scanf(&quot;%d&quot;, &amp;n); int *arr = (int *)malloc(sizeof(int) * n); for(int i = 0; i &lt; n; i++) &#123; val = rand() % 100; arr[i] = val; &#125; output(arr, n); heap_sort(arr, n); output(arr, n); free(arr); return 0;&#125; 优先队列其实就是堆 普通队列 (最大/最小)堆 尾部入队 尾部可以插入 头部入队 头部可以弹出 先进先出 每次出对权值(最大/最小的元素) 数组实现 数组实现，逻辑上看成堆 哈希表哈希函数 1.直接寻址法。取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数） 2.数字分析法。分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。 3.平方取中法。取关键字平方后的中间几位作为散列地址。 4.折叠法。将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。 5.随机数法。选择一随机函数，取关键字作为随机函数的种子生成随机值作为散列地址，通常用于关键字长度不同的场合。 6.除留余数法。取关键字被某个不大于表长m的数p除后所得的余数为散列地址。即 $H(key) = key % p,p&lt;=m$.不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生碰撞。 解决冲突的办法 1. 开放定址法(常用) 如果发⽣冲突，那么就使⽤某种策略寻找下⼀存储地址，直到找到⼀个不冲突的地址或者找到关键字，否则⼀直按这种策略继续寻找。如果冲突次数达到了上限则终⽌程序，表⽰关键字不存在哈希表⾥。常⻅的策略有这⼏种： 线性探测法，如果当前的冲突位置为 d，那么接下来⼏个探测地址为d + 1，d + 2, 等，也就是从冲突地址往后⾯⼀个⼀个探测 线性补偿探测法，它形成的探测地址为 d + m，d + 2 * m ，d + 3 * m等，与线性探测法不同，这⾥的查找单位不是 1，而是 m，为了能遍历到哈希表⾥所有位置，我们设置m 和表⻓szie互质； 随机探测法，这种⽅法和前两种⽅法类似，这⾥的查找单位不是⼀个固定值，而是⼀个随机序列。 ⼆次探测法，它形成的探测地址为 d + 1^2，d - 1^2 ，d + 2^2，d - 2^2 等，这种⽅法在冲突位置左右跳跃着寻找探测地址。 2. 拉链法(常用) 该⽅法将所有哈希地址相同的结点构成⼀个单链表，单链表的头结点存在哈希数组⾥。链地址法常出现在经常插⼊和删除的情况下。优点：不会出现“堆聚”现象，哈希地址不同的关键字不会发⽣冲突；不需要重建哈希表，在开放地址法中，如果哈希表⾥存满关键字了就需要扩充哈希表然后重建哈希表 3. 再哈希法 Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。 4. 建立公共溢出区 冲突次数大于表长的一般时认为堆聚，需要重建 1.开辟一段和当前哈希表等大的临时存储空间。 ​ 2.将原哈希表里的关键字一一复制到临时数组里。 ​ 3.申请一个大小是现在两倍的新的存储空间，释放原空间。 ​ 4.将新空间里的存储地址初始化。 ​ 5.将关键字从临时数组复制到新的空间，释放临时空间。 字符串哈希函数 常见字符串哈希函数：BKDRHash ， APHash ， DJBHash ， JSHash ， RSHash 123456//BKDRHash 法int BKDRHash(char *str) &#123; int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; return hash &amp; 0x7fffffff;&#125; 拉链法写 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;typedef struct Node &#123; char *str; struct Node *next;&#125; Node;typedef struct HashTable &#123; Node **data; int size;&#125; HashTable;Node *init_node(char *str, Node *head) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;str = strdup(str); p-&gt;next = head; return p;&#125;HashTable *init_hashtable(int n) &#123; HashTable *h = (HashTable *)malloc(sizeof(HashTable)); h-&gt;size = n &lt;&lt; 1; h-&gt;data = (Node **)calloc(h-&gt;size, sizeof(Node *)); return h;&#125;int BKDRHash(char *str) &#123; int seed = 31, hash = 0; for(int i = 0; str[i]; i++) hash = hash * seed + str[i]; return hash &amp; 0x7fffffff;&#125;int insert(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size; h-&gt;data[ind] = init_node(str, h-&gt;data[ind]); return 1;&#125;int search(HashTable *h, char *str) &#123; int hash = BKDRHash(str); int ind = hash % h-&gt;size; Node *p = h-&gt;data[ind]; while(p &amp;&amp; strcmp(p-&gt;str, str)) p = p-&gt;next; //条件不能出错xxxxxxxxxxx return p != NULL;&#125; void clear_node(Node *node) &#123; if(node == NULL) return ; Node *p = node, *q; while(p) &#123; q = p-&gt;next; free(p-&gt;str); free(p); p = q; &#125; free(q); return ;&#125;void clear_hashtable(HashTable *h) &#123; if(h == NULL) return ; for(int i = 0; i &lt; h-&gt;size; i++) clear_node(h-&gt;data[i]); free(h-&gt;data); free(h); return ;&#125;int main() &#123; int op; #define max_n 100 char str[max_n + 5]; HashTable *h = init_hashtable(max_n + 5); while(~scanf(&quot;%d%s&quot;, &amp;op, str)) &#123; switch(op) &#123; case 0: printf(&quot;insert %s to hash to table\\n&quot;, str); insert(h, str); break; case 1: printf(&quot;search %s from has table result = %d\\n&quot;, str, search(h, str)); break; &#125; &#125; clear_hashtable(h); return 0;&#125; 排序稳定排序： 常见稳定排序:插入排序，冒泡排序，归并排序 插入排序 基本思想：是将线性表分为已排序的前半部分和待排序的后半部分，从待排序部分选出第⼀个元素，插⼊到已排序部分的对应位置中，直到全部记录都插⼊到已排序部分中。总体时间复杂度O(n^2); 冒泡排序 基本思想：将n个元素比较$n - 1$趟，每一趟比较$n - i$次(即待排元素个数减一)，每一趟都将待排中最大的排到了最后面。时间复杂度O(n^2) 归并排序 基本思想：将两个有序表合成一个有序表，两个有序表如何得到？将原表从中间分成两半，递归的求两边，最后进行一下合并。归并一共进行$O(logn)$层归并，每层时间复杂度$O(n)$,总体时间复杂度$O(nlogn)$,每次合并时要开辟临时空间存储，然后再复制过去，空间复杂度$O(n)$ 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#define swap(a, b) &#123;\\ a ^= b; b ^= a; a ^= b;\\&#125;//插入排序void insert_sort(int *num, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; for(int j = i; j &gt; 0 &amp;&amp; num[j] &lt; num[j-1]; j--) &#123; swap(num[j], num[j - 1]); &#125; &#125; return ;&#125;//冒泡排序void bubble_sort(int *num, int n) &#123; int times = 1; for(int i = 1; i &lt; n &amp;&amp; times; i++) &#123; times = 0; for(int j = 0; j &lt; n - i; j++) &#123; if(num[j] &gt; num[j + 1]) &#123; swap(num[j], num[j + 1]); times++; &#125; &#125; &#125; return ;&#125;//归并排序void merge_sort(int *num, int l, int r) &#123; //if(l == r) return ; if(r - l &lt;= 1) &#123; if(r - l == 1 &amp;&amp; num[l] &gt; num[r]) &#123; swap(num[l], num[r]); &#125; return ; &#125; int mid = (l + r) &gt;&gt; 1; merge_sort(num, l, mid); merge_sort(num, mid + 1, r); int *temp = (int *)malloc(sizeof(int) * (r - l + 1)); int p1 = l, p2 = mid + 1, k = 0; while(p1 &lt;= mid || p2 &lt;= r) &#123; if(p2 &gt; r || (p1 &lt;= mid &amp;&amp; num[p1] &lt;= num[p2])) &#123; temp[k++] = num[p1++]; &#125; else &#123; temp[k++] = num[p2++]; &#125; &#125; memcpy(num + l, temp, sizeof(int) * (r - l + 1)); free(temp); return ;&#125; 非稳定排序： 常见的不稳定排序算法有选择排序(selection sort)、快速排序(quick sort)、堆排序(heap sort)、希尔排序(shell sort) 选择排序 基本思想：分成已排序区(在前)和待排序区,每次从待排序区中找出最小的放已排序的最后面即放在待排序的第一位。或这样理解，一趟都将待排序区的最小值放最前面(跟待排序第一个数交换)，待排序区的元素每趟都会少一个。因为在找待排序区中最小元素时都是将后面的元素跟第一个比较，找到后跟第一个数交换位置，因此可知会打乱后面与第一个数相等的数他俩的相对位置，所以选择排序是不稳定的。也有可能第一个数就是待排区中的最小的数，这时候在写swap函数时就不能用异或运算来写，同一个地址的元素异或交换就变成0了。时间复杂度O(n^2) 快速排序 基本思想：选一个基准值,利用双指针将所有小于基准值的元素放到左边，所有大于基准值的元素放到右边，再递归的将左右两边元素分别排序。平均时间复杂度O(log(n)),最坏O(n^2) 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;//函数测试框架，稳定排序一样用法#define TEST(arr, n, func, args...) &#123;\\ int *num = (int *)malloc(sizeof(int) * n);\\ memcpy(num, arr, sizeof(int) * n);\\ output(num, n);\\ printf(&quot;%s = &quot;, #func);\\ func(args);\\ output(num, n);\\ free(num);\\&#125;//选择排序void select_sort(int *num, int n) &#123; for(int i = 0; i &lt; n - 1; i++) &#123; int ind = i; for(int j = i + 1; j &lt; n; j++) &#123; if(num[j] &lt; num[ind]) ind = j; &#125; swap(num[i], num[ind]); &#125; return ;&#125;//快速排序void quick_sort(int *num, int l, int r) &#123; if(r &lt; l) return ; int x = l, y = r, pivot = num[l]; while(x &lt; y) &#123; //先从右边开始找第一个小于Pivot的值 while(x &lt; y &amp;&amp; num[y] &gt;= pivot) y--; if(x &lt; y) num[x++] = num[y]; while(x &lt; y &amp;&amp; num[x] &lt;= pivot) x++; if(x &lt; y) num[y--] = num[x]; &#125; num[x] = pivot; quick_sort(num, l, x - 1); quick_sort(num, x + 1, r); return ;&#125;void randint(int *arr, int n) &#123; while(n--) arr[n] = rand() % 100; return ;&#125;void output(int *num, int n) &#123; printf(&quot;[ &quot;); for(int i = 0; i &lt; n; i++) &#123; printf(&quot;%d &quot;, num[i]); &#125; printf(&quot;]\\n&quot;); return ;&#125;int main() &#123; srand(time(0)); #define max_op 15 int arr[max_op]; randint(arr, max_op); TEST(arr, max_op, select_sort, num, max_op); TEST(arr, max_op, quick_sort, num, 0, max_op - 1); return 0;&#125; 查找二分查找：解决的是将问题规模减小 普通情况： 在有序序列找一个数 1234567891011//1 3 5 7 9 10 ......int binary_search1(int *num, int n, int x) &#123; int head = 0, tail = n - 1, mid; while(head &lt;= tail) &#123; mid = (head + tail) &gt;&gt; 1; if(num[mid] == x) return mid; if(num[mid] &lt; x) head = mid + 1; else tail = mid - 1; &#125; return -1;&#125; 000000011111情况: 找第一个1的位置 123456789int binary_search2(int *num, int n) &#123; int head = 0, tail = n, mid; // 一定存在答案的话，应该可以tail = n - 1开始。。 while(head &lt; tail) &#123; mid = (head + tail) &gt;&gt; 1; //重点注意 if(num[mid] == 1) tail = mid; else head = mid + 1; &#125; return head == n ? -1 : head;&#125; ① $mid = (head + tail) / 2$ 如果此时 0 0 0 0 0 0 1 1 1 1 ↑ ↑ l r 下一次 mid = (l + r) / 2 == l 更新 r = mid = l; 正好得到答案不会死循环，所以求 mid 时 l + r 不用再加1 11111110000的情况则不同(下面分析) ② $head = mid + 1$ 12345000000011111 ↑head &#x3D; mid + 1;如果此时 mid 指向的是0那么他一定不是答案，所以舍去 mid 及前面的 ③ $tail = mid$ 12345000000011111 ↑tail &#x3D; mid;如果此时 mid 指向的是1那么他 有可能 是答案，所以留下 mid， 舍弃mid后面的 111111111100000情况 求最后一个1的位置 12345678910int binary_search3(int *num, int n) &#123; int head = -1, tail = n - 1, mid; //一定存在答案的话，应该可以head = 0开始。。 while(head &lt; tail) &#123; mid = (head + tail + 1) &gt;&gt; 1; //重点关注 if(num[mid] == 1) &#123; head = mid; &#125; else tail = mid - 1; &#125; return head;&#125; ① $mid = (head + tail + 1) / 2$ 12345678910如果此时1 1 1 1 1 1 1 1 0 0 0 0 ↑ ↑ l r如果 mid &#x3D; (l + r) &#x2F; 2;那么下一次 mid &#x3D; (l + r) &#x2F; 2 &#x3D;&#x3D; l; 更新 l &#x3D; mid &#x3D; l; l 还是 l这时就会死循环 所以应该 mid &#x3D; (head + tail + 1) &#x2F; 2； ② $head = mid$ 1234511111110000000000000 ↑head &#x3D; mid;如果此时 mid 指向的 1 ,那么他有可能是答案，所以舍去 mid 前面的，留下 mid ③ $tail = mid$ 123451111110000000 ↑tail &#x3D; mid - 1;如果此时 mid 指向的是 0 那么他一定不是答案，所以舍弃 mid 及后面的 三分查找： 在一个单调函数中，用二分查找精确求解中某一点的值。如果函数是一个 凸性函数（在某一点左侧，函数递增，在该点右侧，函数递减，该点称为极大值点）或者 凹性函数（在某一点左侧，函数递减，在该点右侧，函数递增，该点称为极小值点）求最值就要用到三分查找 三分查找每次比较后，都会将区间长度缩小到原来的$2/3$ 。时间复杂度Olog(n); 123456789101112131415161718192021222324252627//凸函数代码//凹函数只需要把10，16行大于改成小于即可#include &lt;stdio.h&gt;int find_max(int *data, int length) &#123; int left = 0, right =length - 1; while(right - left &gt;= 2) &#123; int m1 = left + (right - left) / 3; int m2 = right - (right - left + 2) / 3; //尽量让m2靠近极值点 if(data[m1] &gt;= data[m2]) &#123; right = m2; &#125; else &#123; left = m1 + 1;//尽量让m1靠近极值点 &#125; &#125; if(data[left] &gt;= data[right]) &#123; return left; &#125; else &#123; return right; &#125;&#125;int main() &#123; int a[5] = &#123;1, 2, 7, 5, 4&#125;; printf(&quot;%d\\n&quot;, find_max(a, 5)); return 0;&#125; 平衡二叉查找树二叉排序树又称二叉搜索树 **左子树 &lt; 根结点 ** 右子树 &gt; 根结点 用途: 解决排名相关的检索需求 ⼆叉查找树插⼊查找的效率都是 O(log n)，最坏情况下是 O(n) 二叉查找树插入 小于根结点插左子树，大于根结点插右子树 二叉查找树删除 删除叶子节点 删除出度为1的节点 如图删除3 ➡ 删除出度为2的节点 先找到前驱或后继，然后替换后转换为出度为1的节点问题 如图删除20 ➡➡ ➡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;typedef struct Node &#123; int key; struct Node *lchild, *rchild;&#125; Node;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;lchild = p-&gt;rchild = NULL; return p;&#125;Node *insert(Node *root, int key) &#123; if(root == NULL) return getNewNode(key); if(root-&gt;key == key) return root; if(key &lt; root-&gt;key) root-&gt;lchild = insert(root-&gt;lchild, key); else root-&gt;rchild = insert(root-&gt;rchild, key); return root;&#125;Node *predecessor(Node *root) &#123; Node *temp = root-&gt;lchild; while(temp-&gt;rchild) temp = temp-&gt;rchild; return temp;&#125;//删除节点重要！Node *erase(Node *root, int key) &#123; if(root == NULL) return root; if(key &lt; root-&gt;key) root-&gt;lchild = erase(root-&gt;lchild, key); else if(key &gt; root-&gt;key) root-&gt;rchild = erase(root-&gt;rchild, key); else &#123; //度为一或0 if(root-&gt;lchild == NULL || root-&gt;rchild == NULL) &#123; Node *temp = root-&gt;lchild ? root-&gt;lchild : root-&gt;rchild; free(root); return temp; &#125; else &#123; //度为2的节点 Node *temp = predecessor(root); root-&gt;key = temp-&gt;key; root-&gt;lchild = erase(root-&gt;lchild, temp-&gt;key); &#125; &#125; return root;&#125;void __in_order(Node *root) &#123; if(root == NULL) return ; __in_order(root-&gt;lchild); printf(&quot;%d &quot;, root-&gt;key); __in_order(root-&gt;rchild); return ;&#125;void in_order(Node *root) &#123; printf(&quot;in order output: &quot;); __in_order(root); printf(&quot;\\n&quot;);&#125;void clear(Node *root) &#123; if(root == NULL) return ; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return ;&#125;int main() &#123; int op, val; Node *root = NULL; while(~scanf(&quot;%d%d&quot;, &amp;op, &amp;val)) &#123; switch(op) &#123; case 1: root = insert(root, val); break; case 2: root = erase(root, val); break; &#125; in_order(root); &#125; clear(root); return 0;&#125; 平衡二叉查找树AVL树 平衡条件：每个节点左右子树最大高度差不超过1 四种旋转操作： LL型 LR型：首先是左子树比右子树高度差为2了，又左子树的右子树比左子树的左子树高，此时需要先站在左孩子处进行小左旋，再站在当前节点进行大右旋 RL型 RR型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define H(root) (root)-&gt;h#define L(root) (root)-&gt;l#define R(root) (root)-&gt;r#define K(root) (root)-&gt;keytypedef struct Node &#123; int key, h; struct Node *l, *r;&#125; Node;Node __NIL;#define NIL (&amp;__NIL)__attribute__((constructor))void init_NIL() &#123; NIL-&gt;key = NIL-&gt;h = 0; NIL-&gt;l = NIL-&gt;r = NIL; return ;&#125;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;h = 1; p-&gt;l = p-&gt;r = NIL; return p;&#125;void update_height(Node *root) &#123; root-&gt;h = H(L(root))&gt; H(R(root)) ? H(L(root)) : H(R(root)) + 1;&#125;Node *left_rotate(Node *root) &#123; Node *temp = root-&gt;r; root-&gt;r = temp-&gt;l; temp-&gt;l = root; update_height(root); update_height(temp); return temp;&#125;Node *right_rotate(Node *root) &#123; Node *temp = root-&gt;l; root-&gt;l = temp-&gt;r; temp-&gt;r = root; update_height(root); update_height(temp); return temp;&#125;Node *maintain(Node *root) &#123; if (abs(H(L(root)) - H(R(root))) &lt;= 1) return root; if (H(L(root)) &gt; H(R(root))) &#123; if(H(R(L(root))) &gt; H(L(L(root)))) &#123; root-&gt;l = left_rotate(root-&gt;l); &#125; root = right_rotate(root); &#125; else &#123; if(H(L(R(root))) &gt; H(R(R(root)))) &#123; root-&gt;l = right_rotate(root-&gt;l); &#125; root = left_rotate(root); &#125; return root;&#125;Node *insert(Node *root, int key) &#123; if (root == NIL) return getNewNode(key); if (root-&gt;key == key) return root; if (root-&gt;key &gt; key) &#123; root-&gt;l = insert(root-&gt;l, key); &#125; else root-&gt;r = insert(root-&gt;r, key); update_height(root); //插入一节点就要更新树高 return maintain(root);&#125;void clear(Node *root) &#123; if (root == NIL) return ; clear(root-&gt;l); clear(root-&gt;r); free(root);&#125; Node *predeccessor(Node *root) &#123; Node *temp = root-&gt;l; while (temp-&gt;r != NIL) temp = temp-&gt;r; return temp;&#125;Node *erase(Node *root, int key) &#123; if (root == NIL) return root; if (root-&gt;key &gt; key) root-&gt;l = erase(root-&gt;l, key); else if (root-&gt;key &lt; key) &#123; root-&gt;r = erase(root-&gt;r, key); &#125; else &#123; if (root-&gt;l == NIL || root-&gt;r == NIL) &#123; Node *temp = root-&gt;l == NIL ? root-&gt;r : root-&gt;l; free(root); return temp; &#125; else &#123; Node *temp = predeccessor(root); root-&gt;key = temp-&gt;key; root-&gt;l = erase(root-&gt;l, temp-&gt;key); &#125; &#125; update_height(root); return maintain(root);&#125;void output(Node *root) &#123; if (root == NIL) return ; printf(&quot;(%d %d %d)\\n&quot;, K(root), K(L(root)), K(R(root))); output(root-&gt;l); output(root-&gt;r); return ;&#125;int main() &#123; #define MAX_OP 20 Node *root = NIL; for(int i = 0; i &lt; MAX_OP; i++) &#123; int val = rand() % 100; root = insert(root, val); &#125; output(root); int val; while(~scanf(&quot;%d&quot;, &amp;val)) &#123; root = erase(root, val); printf(&quot;erase %d from tree&quot;, val); output(root); &#125; return 0;&#125; 红黑树五个平衡条件 每个结点要么是红色，要么是黑色； 根结点是黑色； 叶结点（NIL）是黑色； 如果一个结点是红色，则它的两个子节点都是黑色的； 从根结点出发到所有叶结点的路径上，均包含相同数目的黑色结点。 提示：调整时要明确哪些点的颜色是确定的哪些是不确定的，调整前后要保证这个子树上面的黑色数量没有改变 插入调整(两种情况)==站在祖父节点往下看是否有颜色冲突(看儿子和孙子是不是同时为红色)== 叔叔红 方案：直接红上顶 叔叔黑(我位置有4种情况) LR型：先小左旋(注意观察小左旋并不影响路径上黑色节点数量)，转化为LL型 LL型：直接大右旋，再调帽子为红黑黑或黑红红 RR、RL和上面一样 删除调整(三种情况)删除操作站在父节点往下看 分析删除只有一个孩子的结点的情况：如果要删除的结点 x 为红色，那么这个结点的父结点和子结点都一定是黑色，因此，只需要把子结点直接连向父结点就可以了，不会破坏红黑树的五条规则。如果删除的黑色节点，就需要把该结点下的子树的根结点变为双重黑 调整操作就是为了干掉双重黑 其中分兄弟黑和兄弟红，兄弟红可以转为兄弟黑情况，这里主要分兄弟黑的三种情况 黑兄弟的儿子全黑 x为双重黑 方案：黑上浮（当根结点为双重黑时，直接减一就行） RR或LL型LL黑兄弟是左孩子，黑兄弟的左孩子是只要是红色(不关心另一个孩子颜色) RR黑兄弟是右孩子，黑兄弟的右孩子是只要是红色(不关心另一个孩子颜色) 站在38大左旋， 调色：51调成38的颜色，38和72调成黑色 RL或LR型 先小右旋，交换51调黑72调红，变成了RR型 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define RED 0#define BLACK 1#define DBLACK 2typedef struct Node &#123; int key; int color; // 0 red, 1 black, 2 double black struct Node *lchild, *rchild;&#125; Node;Node __NIL;#define NIL (&amp;__NIL)__attribute__((constructor))void init_NIL() &#123; NIL-&gt;key = 0; NIL-&gt;lchild = NIL-&gt;rchild = NIL; NIL-&gt;color = BLACK; return ;&#125;Node *getNewNode(int key) &#123; Node *p = (Node *)malloc(sizeof(Node)); p-&gt;key = key; p-&gt;lchild = p-&gt;rchild = NIL; p-&gt;color = RED; return p;&#125;bool has_red_child(Node *root) &#123; return root-&gt;lchild-&gt;color == 0 || root-&gt;rchild-&gt;color == 0;&#125;Node *left_rotate(Node *root) &#123; Node *temp = root-&gt;rchild; root-&gt;rchild = temp-&gt;lchild; temp-&gt;lchild = root; return temp;&#125;Node *right_rotate(Node *root) &#123; Node *temp = root-&gt;lchild; root-&gt;lchild = temp-&gt;rchild; temp-&gt;rchild = root; return temp;&#125;Node *insert_maintain(Node *root) &#123; if (!has_red_child(root)) return root; if (root-&gt;lchild-&gt;color == RED &amp;&amp; root-&gt;rchild-&gt;color == RED) &#123; root-&gt;color = RED; root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = BLACK; return root; &#125; if (root-&gt;lchild-&gt;color == RED) &#123; if (!has_red_child(root-&gt;lchild)) return root; if (root-&gt;lchild-&gt;rchild-&gt;color == RED) &#123; root-&gt;lchild = left_rotate(root-&gt;lchild); &#125; root = right_rotate(root); &#125; else &#123; if (!has_red_child(root-&gt;rchild)) return root; if (root-&gt;rchild-&gt;lchild-&gt;color == RED) &#123; root-&gt;rchild = right_rotate(root-&gt;rchild); &#125; root = left_rotate(root); &#125; root-&gt;color = RED; root-&gt;lchild-&gt;color = root-&gt;rchild-&gt;color = BLACK; return root;&#125;Node *predeccessor(Node *root) &#123; Node *temp = root-&gt;lchild; while (temp-&gt;rchild != NIL) temp = temp-&gt;rchild; return temp;&#125;Node *erase_maintain(Node *root) &#123; if (root-&gt;lchild-&gt;color != DBLACK &amp;&amp; root-&gt;rchild-&gt;color != DBLACK) return root; if (has_red_child(root)) &#123; root-&gt;color = RED; if (root-&gt;lchild-&gt;color == RED) &#123; root = right_rotate(root); root-&gt;rchild = erase_maintain(root-&gt;rchild); &#125; else &#123; root = left_rotate(root); root-&gt;lchild = erase_maintain(root-&gt;lchild); &#125; root-&gt;color = BLACK; return root; &#125; if ((root-&gt;lchild-&gt;color == DBLACK &amp;&amp; !has_red_child(root-&gt;rchild)) || (root-&gt;rchild-&gt;color == DBLACK &amp;&amp; !has_red_child(root-&gt;lchild))) &#123; root-&gt;color += 1; root-&gt;lchild-&gt;color -= 1; root-&gt;rchild-&gt;color -= 1; return root; &#125; if (root-&gt;rchild-&gt;color == BLACK) &#123; if (root-&gt;rchild-&gt;rchild-&gt;color != RED) &#123; root-&gt;rchild-&gt;color = RED; root-&gt;rchild = right_rotate(root-&gt;rchild); root-&gt;rchild-&gt;color = BLACK; &#125; root-&gt;rchild-&gt;color = root-&gt;color; root-&gt;color = BLACK; root-&gt;lchild-&gt;color -= 1; root = left_rotate(root); root-&gt;rchild-&gt;color = BLACK; &#125; else &#123; if (root-&gt;lchild-&gt;lchild-&gt;color != RED) &#123; root-&gt;lchild-&gt;color = RED; root-&gt;lchild = left_rotate(root-&gt;lchild); root-&gt;lchild-&gt;color = BLACK; &#125; root-&gt;lchild-&gt;color = root-&gt;color; root-&gt;color = BLACK; root-&gt;rchild-&gt;color -= 1; root = right_rotate(root); root-&gt;lchild-&gt;color = BLACK; &#125; return root;&#125;Node *__erase(Node *root, int key) &#123; if (root == NIL) return root; if (root-&gt;key &gt; key) &#123; root-&gt;lchild = __erase(root-&gt;lchild, key); &#125; else if (root-&gt;key &lt; key) &#123; root-&gt;rchild = __erase(root-&gt;rchild, key); &#125; else &#123; if (root-&gt;lchild == NIL || root-&gt;rchild == NIL) &#123; Node *temp = root-&gt;lchild == NIL ? root-&gt;rchild : root-&gt;lchild; temp-&gt;color += root-&gt;color; free(root); return temp; &#125; else &#123; Node *temp = predeccessor(root); root-&gt;key = temp-&gt;key; root-&gt;lchild = __erase(root-&gt;lchild, temp-&gt;key); &#125; &#125; return erase_maintain(root);&#125;Node *erase(Node *root, int key) &#123; root = __erase(root, key); root-&gt;color = BLACK; return root;&#125;Node *__insert(Node *root, int key) &#123; if (root == NIL) return getNewNode(key); if (root-&gt;key == key) return root; if (root-&gt;key &gt; key) &#123; root-&gt;lchild = __insert(root-&gt;lchild, key); &#125; else &#123; root-&gt;rchild = __insert(root-&gt;rchild, key); &#125; return insert_maintain(root);&#125;Node *insert(Node *root, int key) &#123; root = __insert(root, key); root-&gt;color = BLACK; return root;&#125;void clear(Node *root) &#123; if (root == NIL) return ; clear(root-&gt;lchild); clear(root-&gt;rchild); free(root); return ;&#125;void output(Node *root) &#123; if (root == NIL) return ; printf(&quot;(%d | %d, %d, %d)\\n&quot;, root-&gt;color, root-&gt;key, root-&gt;lchild-&gt;key, root-&gt;rchild-&gt;key ); output(root-&gt;lchild); output(root-&gt;rchild); return ;&#125;int main() &#123; int op, val; Node *root = NIL; while (~scanf(&quot;%d%d&quot;, &amp;op, &amp;val)) &#123; switch (op) &#123; case 0: root = insert(root, val); break; case 1: root = erase(root, val); break; &#125; output(root); &#125; return 0;&#125; 并查集 解决连通性问题 MAKE—SET(x)：初始化操作：建立一个只包含x的元素，每个元素开始都是指向自己 FIND—SET(x) 查询操作：找到x所在的集合 UNION(x, y) 合并操作：将两棵树合并 不加优化的并查集，最坏情况森林会退化成链表，查询时间复杂度为O(N) Quick-Find 将所有连通的即属于同一集合的元素都染成代表元素的颜色，在树中就是都指向最终根结点，路径压缩就是这样子 1234567891011121314151617181920212223242526272829typedef struct UnionSet &#123; int *color; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;color = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for(int i = 1; i &lt;= n; i++) &#123; u-&gt;color[i] = i; &#125; return u;&#125;//查找int find(UnionSet *u, int x) &#123; return u-&gt;color[x];&#125;//合并int merge(UnionSet *u, int a, int b) &#123; if(find(u, a) == find(u, b)) return 0; int color_a = u-&gt;color[a]; for(int i = 1; i &lt;= u-&gt;n; i++) &#123; if(u-&gt;color[i] - color_a) continue; u-&gt;color[i] = u-&gt;color[b]; &#125; return 1;&#125; Quick-Union 解释：[x, y], 将x所在集合连通到y所在集合, x所在集合的代表为X，y所在集合的代表为Y，a[X] = Y 例：用Quick-Union算法求的下面十个点最终数组结果 画成树： 缺点：这样规定x做孩子连在y下面,极端情况下会退化成链表，优化看Weighted Quick-Union 12345678910111213141516171819202122232425262728typedef struct UnionSet &#123; int *father; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for(int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; &#125; return u;&#125;//查找int find(UnionSet *u, int x) &#123; if(u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;//合并int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if(fa == fb) return 0; u-&gt;father[fa] = fb; return 1;&#125; Weighted Quick-Union 这就是：按秩合并 解释：[x, y], 将x所在集合和y所在集合合并, 秩小的做孩子，秩大的做父亲 秩是按照节点数量比较还是树的高度比较呢？ ➟ 节点数量 通俗理解：像下面这种情况，就应该将树二接到树一下面，这样查询效率更高 公式推倒：$l_i$ 表示第$i$个点查询的次数，所有点查询总次数除以节点总数就是平均查找次数 可知应该根据节点数量将节点少的接在节点数量多得树下面 例：分别写出下面用Quick-Union和Weighted Quick-Union得到的数组最终结果 1234567891011121314151617181920212223242526272829303132333435#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet &#123; int *father, *size; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; if(u-&gt;father[x] == x) return x; return find(u, u-&gt;father[x]);&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if (fa == fb) return 0; if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); u-&gt;father[fb] = fa; u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125; Weighted Quick-Union With Path Compression 将所有点都指向它最终的根结点(它所在集合的代表元素)就是路径压缩，如上右图的0指向3 12345678910111213141516171819202122232425262728293031323334#define swap(a, b) &#123;\\ __typeof(a) __temp = a;\\ a = b; b = __temp;\\&#125;typedef struct UnionSet &#123; int *father, *size; int n;&#125; UnionSet;UnionSet *init(int n) &#123; UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet)); u-&gt;father = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;size = (int *)malloc(sizeof(int) * (n + 1)); u-&gt;n = n; for (int i = 1; i &lt;= n; i++) &#123; u-&gt;father[i] = i; //u-&gt;size[i] = 1; &#125; return u;&#125;int find(UnionSet *u, int x) &#123; return u-&gt;father[x] = (u-&gt;father[x] == x ? x : find(u, u-&gt;father[x]));&#125;int merge(UnionSet *u, int a, int b) &#123; int fa = find(u, a), fb = find(u, b); if (fa == fb) return 0; //if (u-&gt;size[fa] &lt; u-&gt;size[fb]) swap(fa, fb); u-&gt;father[fb] = fa; //u-&gt;size[fa] += u-&gt;size[fb]; return 1;&#125; 复杂度比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct DisjointSet&#123; int *father, *rank;&#125; DisjointSet;void init(DisjointSet *s, int size) &#123; s-&gt;father = (int *)malloc(sizeof(int) * size); s-&gt;rank = (int *)malloc(sizeof(int) * size); for (int i = 0; i &lt; size; ++i) &#123; s-&gt;father[i] = i; s-&gt;rank[i] = 1; &#125;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int find_set(DisjointSet *s, int node) &#123; if (s-&gt;father[node] != node) &#123; s-&gt;father[node] = find_set(s, s-&gt;father[node]); &#125; return s-&gt;father[node];&#125;int merge(DisjointSet *s, int node1, int node2) &#123; int ancestor1 = find_set(s, node1); int ancestor2 = find_set(s, node2); if (ancestor1 != ancestor2) &#123; if (s-&gt;rank[ancestor1] &gt; s-&gt;rank[ancestor2]) &#123; swap(&amp;ancestor1, &amp;ancestor2); &#125; s-&gt;father[ancestor1] = ancestor2; s-&gt;rank[ancestor2] = max(s-&gt;rank[ancestor2], s-&gt;rank[ancestor1] + 1); return 1; &#125; return 0;&#125;void clear(DisjointSet *s) &#123; free(s-&gt;father); free(s-&gt;rank); free(s);&#125;int main() &#123; DisjointSet *dsu = (DisjointSet *)malloc(sizeof(DisjointSet)); init(dsu, 100); int m, x, y; scanf(&quot;%d&quot;, &amp;m); for (int i = 0; i &lt; m; ++i) &#123; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int ans = merge(dsu, x, y); if (ans) &#123; printf(&quot;success\\n&quot;); &#125; else &#123; printf(&quot;failed\\n&quot;); &#125; &#125; clear(dsu); return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct DisjointSet &#123; int *father, *rank;&#125;DisjointSet;void init(DisjointSet *s, int size) &#123; s-&gt;father = (int *)malloc(sizeof(int) * size); s-&gt;rank = (int *)malloc(sizeof(int) * size); for (int i = 0; i &lt; size; ++i) &#123; s-&gt;father[i] = i; s-&gt;rank[i] = 1; &#125;&#125;void swap(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int find_set(DisjointSet *s, int node) &#123; return s-&gt;father[node];&#125;int merge(DisjointSet *s, int node1, int node2) &#123; int ancestor1 = find_set(s, node1); int ancestor2 = find_set(s, node2); if (ancestor1 != ancestor2) &#123; if (s-&gt;rank[ancestor1] &gt; s-&gt;rank[ancestor2]) &#123; swap(&amp;ancestor1, &amp;ancestor2); &#125; s-&gt;father[ancestor1] = ancestor2; s-&gt;rank[ancestor2] = max(s-&gt;rank[ancestor2], s-&gt;rank[ancestor1] + 1); //s-&gt;rank[ancestor2] += s-&gt;rank[ancestor1]; return 1; &#125; return 0;&#125;void clear(DisjointSet *s) &#123; free(s-&gt;father); free(s-&gt;rank); free(s);&#125;int main() &#123; int m, n; DisjointSet *s = (DisjointSet *)malloc(sizeof(DisjointSet)); scanf(&quot;%d %d&quot;, &amp;m, &amp;n); init(s, m); int a, b; for(int i = 0; i &lt; n; i++) &#123; scanf(&quot;%d%d&quot;, &amp;a, &amp;b); merge(s, a, b); &#125; for(int i = 0; i &lt; m; i++) &#123; printf(&quot;%d\\n&quot;, find_set(s, i)); &#125; return 0;&#125;","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","slug":"1.hello-world","date":"2020-08-06T10:40:30.951Z","updated":"2020-08-11T13:01:28.977Z","comments":true,"path":"2020/08/06/1.hello-world/","link":"","permalink":"http://yoursite.com/2020/08/06/1.hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}],"categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"},{"name":"其他","slug":"其他","permalink":"http://yoursite.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"c++","slug":"c","permalink":"http://yoursite.com/tags/c/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}